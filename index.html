<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>英雄タイタン強さ評価ツール v2.0 Phase 3</title></title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Rajdhani', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 50%, #0f172a 100%);
      color: #f1f5f9;
      min-height: 100vh;
      padding: 1rem;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    /* ヘッダー */
    .header {
      background: linear-gradient(to right, #2563eb, #9333ea);
      padding: 1.5rem;
      border-radius: 0.5rem;
      margin-bottom: 2rem;
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.5), inset 0 0 20px rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.3);
    }

    .header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.5rem;
      font-weight: 900;
      text-align: center;
      text-shadow: 0 0 10px rgba(59, 130, 246, 0.8);
      letter-spacing: 0.1em;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .header p {
      text-align: center;
      color: #bfdbfe;
      margin-top: 0.5rem;
      font-size: 1.125rem;
    }

    /* バージョンバッジ */
    .version-badge {
      display: inline-block;
      background: rgba(34, 197, 94, 0.2);
      color: #86efac;
      padding: 0.25rem 0.75rem;
      border-radius: 1rem;
      font-size: 0.875rem;
      margin-left: 0.5rem;
      border: 1px solid #86efac;
    }

    /* 警告表示 */
    .warning {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid #ef4444;
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #fca5a5;
      font-weight: 600;
    }

    /* グリッドレイアウト */
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }

    @media (min-width: 1024px) {
      .grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* カード */
    .card {
      background: rgba(30, 41, 59, 0.5);
      backdrop-filter: blur(10px);
      padding: 1.5rem;
      border-radius: 0.5rem;
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.5), inset 0 0 20px rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.3);
      transition: all 0.3s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(59, 130, 246, 0.6);
    }

    .card h2 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: #60a5fa;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    /* フォーム要素 */
    .form-group {
      margin-bottom: 0.75rem;
    }

    .form-label {
      display: block;
      font-size: 0.875rem;
      font-weight: 600;
      color: #cbd5e1;
      margin-bottom: 0.25rem;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border-radius: 0.375rem;
      border: 1px solid rgba(59, 130, 246, 0.3);
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(10px);
      color: white;
      font-family: 'Rajdhani', sans-serif;
      font-size: 1rem;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: #60a5fa;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
    }

    /* ボタン */
    .btn {
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      border: none;
      font-weight: 600;
      font-family: 'Rajdhani', sans-serif;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .btn-primary {
      background: #1e40af;
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
      box-shadow: 0 0 20px rgba(37, 99, 235, 0.5);
    }

    .btn-primary.active {
      background: #2563eb;
      box-shadow: 0 0 20px rgba(37, 99, 235, 0.5);
    }

    .btn-secondary {
      background: #334155;
      color: #d1d5db;
    }

    .btn-secondary:hover {
      background: #475569;
    }

    /* トグルスイッチ */
    .toggle-container {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 0.375rem;
      border: 1px solid rgba(59, 130, 246, 0.3);
    }

    .toggle-switch {
      position: relative;
      width: 50px;
      height: 26px;
      background: #475569;
      border-radius: 13px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle-switch.active {
      background: #2563eb;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(24px);
    }

    .toggle-label {
      font-weight: 600;
      font-size: 1rem;
      color: #e2e8f0;
    }

    /* プリセットボタングリッド */
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    .preset-btn {
      background: #334155;
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 0.375rem;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Rajdhani', sans-serif;
      font-weight: 600;
    }

    .preset-btn:hover {
      background: #2563eb;
      box-shadow: 0 0 20px rgba(37, 99, 235, 0.5);
    }

    .preset-label {
      font-size: 0.75rem;
      color: #9ca3af;
      display: block;
      margin-bottom: 0.25rem;
    }

    .preset-heroes {
      font-size: 0.875rem;
    }

    /* 相性ボタン */
    .compatibility-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .compatibility-buttons .btn {
      flex: 1;
    }

    /* 英雄カード */
    .hero-card {
      background: rgba(15, 23, 42, 0.6);
      padding: 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(59, 130, 246, 0.2);
      margin-bottom: 1rem;
    }

    .hero-title {
      font-size: 1.125rem;
      font-weight: 700;
      color: #93c5fd;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    /* 兵種バッジ */
    .hero-type-badge {
      font-size: 0.75rem;
      padding: 0.125rem 0.5rem;
      border-radius: 0.25rem;
      font-weight: 600;
    }

    .type-land { 
      background: rgba(168, 85, 247, 0.2); 
      color: #c084fc; 
      border: 1px solid #c084fc; 
    }

    .type-sea { 
      background: rgba(59, 130, 246, 0.2); 
      color: #60a5fa; 
      border: 1px solid #60a5fa; 
    }

    .type-air { 
      background: rgba(34, 197, 94, 0.2); 
      color: #86efac; 
      border: 1px solid #86efac; 
    }

    .hero-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
    }

    /* タイタン装備 */
    .titan-section {
      background: rgba(15, 23, 42, 0.6);
      padding: 1rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(59, 130, 246, 0.2);
      margin-bottom: 1.5rem;
    }

    .titan-hero-name {
      font-size: 1.125rem;
      font-weight: 700;
      color: #c084fc;
      margin-bottom: 0.75rem;
    }

    .titan-slot {
      background: rgba(30, 41, 59, 0.5);
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin-bottom: 0.75rem;
    }

    .titan-slot-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      font-weight: 600;
      color: #cbd5e1;
      margin-bottom: 0.5rem;
    }

    .titan-slot-icon {
      width: 20px;
      height: 20px;
      stroke: currentColor;
      fill: none;
    }

    .titan-slot-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    /* 結果ボックス */
    .result-box {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(15, 23, 42, 0.9) 100%);
      border-left: 3px solid #3b82f6;
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin-bottom: 0.5rem;
    }

    .result-label {
      color: #9ca3af;
      font-size: 0.875rem;
      margin-bottom: 0.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .result-value {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .result-increase {
      font-size: 0.75rem;
      color: #34d399;
      margin-left: 0.5rem;
    }

    .value-green { color: #86efac; }
    .value-red { color: #fca5a5; }
    .value-yellow { color: #fde047; }
    .value-orange { color: #fdba74; }
    .value-blue { color: #93c5fd; }
    .value-purple { color: #c084fc; }

    .result-highlight {
      background: linear-gradient(to right, rgba(127, 29, 29, 0.3), rgba(153, 27, 27, 0.3));
    }

    .result-highlight-green {
      background: linear-gradient(to right, rgba(20, 83, 45, 0.3), rgba(21, 128, 61, 0.3));
    }

    /* 結果表示の2列グリッド */
    .result-grid-2 {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    .result-grid-2 .result-box {
      margin-bottom: 0;
    }

    /* タブ折りたたみ */
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      user-select: none;
      margin-bottom: 1rem;
    }

    .card-header h2 {
      margin-bottom: 0;
    }

    .collapse-icon {
      font-size: 1.25rem;
      transition: transform 0.3s ease;
    }

    .collapse-icon.collapsed {
      transform: rotate(-90deg);
    }

    .card-content {
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
    }

    .card-content.hidden {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }

    /* アイコン */
    .icon {
      display: inline-block;
      width: 24px;
      height: 24px;
      vertical-align: middle;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .icon-large {
      width: 40px;
      height: 40px;
    }

    /* スペーシング */
    .space-y-1 > * + * { margin-top: 0.25rem; }
    .space-y-2 > * + * { margin-top: 0.5rem; }
    .space-y-3 > * + * { margin-top: 0.75rem; }
    .space-y-4 > * + * { margin-top: 1rem; }
    .space-y-6 > * + * { margin-top: 1.5rem; }

    /* レスポンシブ調整 */
    @media (max-width: 640px) {
      .header h1 {
        font-size: 1.5rem;
      }
      
      .preset-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo } = React;

    // アイコンコンポーネント
    const ShieldIcon = () => (
      <svg className="icon" viewBox="0 0 24 24">
        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
      </svg>
    );

    const SwordsIcon = () => (
      <svg className="icon" viewBox="0 0 24 24">
        <path d="M14.5 17.5 3 6V3h3l11.5 11.5M13 19l6-6M16 16l4 4M19 21l2-2"></path>
      </svg>
    );

    const UsersIcon = () => (
      <svg className="icon" viewBox="0 0 24 24">
        <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2M9 11a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM22 21v-2a4 4 0 0 0-3-3.87M16 3.13a4 4 0 0 1 0 7.75"></path>
      </svg>
    );

    const SettingsIcon = () => (
      <svg className="icon" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M12 1v6m0 6v6M5.6 5.6l4.2 4.2m4.2 4.2 4.2 4.2M1 12h6m6 0h6M5.6 18.4l4.2-4.2m4.2-4.2 4.2-4.2"></path>
      </svg>
    );

    const CalculatorIcon = () => (
      <svg className="icon icon-large" viewBox="0 0 24 24">
        <rect x="4" y="2" width="16" height="20" rx="2"></rect>
        <line x1="8" y1="6" x2="16" y2="6"></line>
        <line x1="16" y1="14" x2="16" y2="18"></line>
        <line x1="8" y1="14" x2="8" y2="18"></line>
        <line x1="12" y1="14" x2="12" y2="18"></line>
      </svg>
    );

    const AlertIcon = () => (
      <svg className="icon" viewBox="0 0 24 24">
        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
        <line x1="12" y1="9" x2="12" y2="13"></line>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
    );

    // タイタン装備アイコン
    const RifleIcon = () => (
      <svg className="titan-slot-icon" viewBox="0 0 24 24">
        <path d="M6 8h8M6 12h8M6 16h8M14 4h3a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1h-3M2 8h2M2 12h2M2 16h2"></path>
        <rect x="14" y="8" width="6" height="4" rx="1"></rect>
      </svg>
    );

    const ArmorIcon = () => (
      <svg className="titan-slot-icon" viewBox="0 0 24 24">
        <path d="M12 2L4 6v6c0 5.55 3.84 10.74 8 12 4.16-1.26 8-6.45 8-12V6l-8-4z"></path>
        <path d="M12 8v8M8 10l4 2 4-2"></path>
      </svg>
    );

    const VisionIcon = () => (
      <svg className="titan-slot-icon" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="10"></circle>
        <circle cx="12" cy="12" r="6"></circle>
        <circle cx="12" cy="12" r="2"></circle>
        <path d="M2 12h3M19 12h3M12 2v3M12 19v3"></path>
      </svg>
    );

    const HeadIcon = () => (
      <svg className="titan-slot-icon" viewBox="0 0 24 24">
        <path d="M3 18v-6a9 9 0 0 1 18 0v6"></path>
        <path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>
      </svg>
    );

    const HandyIcon = () => (
      <svg className="titan-slot-icon" viewBox="0 0 24 24">
        <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"></path>
        <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"></path>
      </svg>
    );

    const BootsIcon = () => (
      <svg className="titan-slot-icon" viewBox="0 0 24 24">
        <path d="M6 3v6l-3 4v5a3 3 0 0 0 3 3h2"></path>
        <path d="M14 3v6l3 4v5a3 3 0 0 1-3 3h-2"></path>
        <path d="M6 9h8M6 15h8"></path>
      </svg>
    );

    const slotIcons = {
      rifle: RifleIcon,
      armor: ArmorIcon,
      vision: VisionIcon,
      head: HeadIcon,
      handy: HandyIcon,
      boots: BootsIcon
    };

    // ユーティリティ関数
    const formatNumber = (num) => {
      if (num === 0) return '0';
      const absNum = Math.abs(num);
      const sign = num < 0 ? '-' : '';
      
      // 有効数字4桁
      const sigFigs = 4;
      
      if (absNum < 1000) {
        const digits = Math.floor(Math.log10(absNum)) + 1;
        const decimals = Math.max(0, sigFigs - digits);
        return sign + absNum.toFixed(decimals);
      }
      
      const units = ['', 'k', 'M', 'B', 'T', 'aa', 'bb', 'cc', 'dd', 'ee', 'ff', 'gg', 'hh', 'ii', 'jj', 'kk', 'll', 'mm', 'nn', 'oo', 'pp', 'qq', 'rr', 'ss', 'tt', 'uu', 'vv', 'ww', 'xx', 'yy', 'zz'];
      const tier = Math.floor(Math.log10(absNum) / 3);
      
      if (tier <= units.length - 1) {
        const scaled = absNum / Math.pow(1000, tier);
        const digits = Math.floor(Math.log10(scaled)) + 1;
        const decimals = Math.max(0, sigFigs - digits);
        return sign + scaled.toFixed(decimals) + units[tier];
      }
      
      return sign + absNum.toExponential(sigFigs - 1);
    };

    // データ定義
    const soldierData = {
      103: { durability: 23.1, power: 2.89 },
      102: { durability: 21.3, power: 2.66 },
      101: { durability: 19.7, power: 2.45 },
      100: { durability: 18.2, power: 2.33 },
      83: { durability: 3.8, power: 0.989 },
      82: { durability: 3.5, power: 0.88 },
      81: { durability: 3, power: 0.75 },
      80: { durability: 2.6, power: 0.65 }
    };

    const exclusiveMultipliers = { 0: 1.0, 3: 1.1, 5: 1.21, 7: 1.34 };

    // ラウンド重み係数（火力用）- 敵の鉄壁条件に応じて変化
    const getDefaultPowerRoundWeights = (enemyIronWall) => {
      if (enemyIronWall === '鉄壁無し') {
        return [0.5, 0.3, 0.15, 0.05];
      } else if (enemyIronWall === '専用なし') {
        return [0.3, 0.4, 0.2, 0.1];
      } else if (enemyIronWall === '専用5') {
        return [0.32, 0.22, 0.27, 0.19];
      } else if (enemyIronWall === '専用7') {
        return [0.27, 0.21, 0.36, 0.16];
      } else if (enemyIronWall === '専用7＋Lv7破壊不能') {
        return [0.28, 0.25, 0.28, 0.19];
      }
      // デフォルト（専用5の値）
      return [0.32, 0.22, 0.27, 0.19];
    };
    
    // ラウンド重み係数（耐久用）- デフォルト
    const defaultDurabilityRoundWeights = [0.32, 0.22, 0.27, 0.19];

    // 衰弱率テーブル（付与数1個用）
    const debuffRate1 = {
      18: { noRush: 13.25, withRush: 16.48 },
      20: { noRush: 14.58, withRush: 18.13 },
      22: { noRush: 15.89, withRush: 19.75 },
      24: { noRush: 17.17, withRush: 21.34 },
      26: { noRush: 18.42, withRush: 22.91 },
      28: { noRush: 19.65, withRush: 24.44 },
      30: { noRush: 20.81, withRush: 25.86 },
      31: { noRush: 21.44, withRush: 26.65 },
      32: { noRush: 22.06, withRush: 27.42 },
      34: { noRush: 23.28, withRush: 28.96 },
      35: { noRush: 23.88, withRush: 29.74 },
      36: { noRush: 24.48, withRush: 30.49 },
      37: { noRush: 25.08, withRush: 31.25 },
      38: { noRush: 25.67, withRush: 32.00 },
      39: { noRush: 26.26, withRush: 32.74 },
      40: { noRush: 26.84, withRush: 33.48 },
      41: { noRush: 27.42, withRush: 34.22 },
      42: { noRush: 28.00, withRush: 34.96 }
    };

    // 衰弱率テーブル（付与数2個用）
    const debuffRate2 = {
      18: { noRush: 24.81, withRush: 30.06 },
      20: { noRush: 27.13, withRush: 32.88 },
      22: { noRush: 29.38, withRush: 35.61 },
      24: { noRush: 31.55, withRush: 38.24 },
      26: { noRush: 33.64, withRush: 40.77 },
      28: { noRush: 35.65, withRush: 43.21 },
      30: { noRush: 37.13, withRush: 45.03 },
      31: { noRush: 38.08, withRush: 46.19 },
      32: { noRush: 39.01, withRush: 47.34 },
      34: { noRush: 40.83, withRush: 49.57 },
      35: { noRush: 41.71, withRush: 50.66 },
      36: { noRush: 42.59, withRush: 51.73 },
      37: { noRush: 43.45, withRush: 52.78 },
      38: { noRush: 44.29, withRush: 53.82 },
      39: { noRush: 45.12, withRush: 54.84 },
      40: { noRush: 45.94, withRush: 55.85 },
      41: { noRush: 46.74, withRush: 56.84 },
      42: { noRush: 47.53, withRush: 57.81 }
    };

    // 衰弱率を取得する関数（線形補正対応）
    const getDebuffRate = (asRate, count, hasRush) => {
      const ratePercent = Math.round(asRate * 100);
      const table = count === 1 ? debuffRate1 : debuffRate2;
      const key = hasRush ? 'withRush' : 'noRush';
      
      // テーブルのキー（発動率）を数値配列に変換してソート
      const rates = Object.keys(table).map(r => parseInt(r)).sort((a, b) => a - b);
      const minRate = rates[0];  // 18
      const maxRate = rates[rates.length - 1];  // 42
      
      // 範囲内の場合：最も近い値を使用
      if (ratePercent >= minRate && ratePercent <= maxRate) {
        let closestRate = minRate;
        let minDiff = Math.abs(ratePercent - minRate);
        
        for (const rate of rates) {
          const diff = Math.abs(ratePercent - rate);
          if (diff < minDiff || (diff === minDiff && rate > closestRate)) {
            closestRate = rate;
            minDiff = diff;
          }
        }
        
        return table[closestRate][key] / 100;
      }
      
      // 最小以下の場合：0%と最小値の間で線形補正
      if (ratePercent < minRate) {
        const minValue = table[minRate][key];
        // (0%, 0) と (minRate%, minValue%) の間で補間
        return (minValue / minRate) * ratePercent / 100;
      }
      
      // 最大以上の場合：最大2つの値の間で線形補正
      const secondMaxRate = rates[rates.length - 2];
      const maxValue = table[maxRate][key];
      const secondMaxValue = table[secondMaxRate][key];
      
      // 傾き = (maxValue - secondMaxValue) / (maxRate - secondMaxRate)
      const slope = (maxValue - secondMaxValue) / (maxRate - secondMaxRate);
      const extrapolatedValue = maxValue + slope * (ratePercent - maxRate);
      
      return extrapolatedValue / 100;
    };

    const heroData = {
      '外す': {
        name: '外す',
        type: '汎用'
      },
      'ペトラ': {
        type: '陸軍',
        attackBuff: (ex) => 100 * exclusiveMultipliers[ex],
        magneticBoost: (ex) => ex >= 7 ? 120 : 70,
        asRate: 37,
        asDamage: (ex) => 60 * exclusiveMultipliers[ex],
        asBullets: (ex) => ex >= 5 ? 5 : 4,
        asExtraEffect: (ex, hasCombo) => hasCombo ? { damage: 50, bullets: (ex >= 5 ? 5 : 4) * 0.5 * 1.5, type: 'magnetic' } : null
      },
      'ミヤ': {
        type: '陸軍',
        shieldBuff: (ex) => 68 * exclusiveMultipliers[ex],
        asRate: 34,
        asDamage: (ex) => 60 * exclusiveMultipliers[ex],
        asBullets: 4,
        psMagneticDamage: (ex) => ex >= 5 ? 60 : 40,
        psMagneticBullets: (ex) => {
          let base = 2.2;
          if (ex >= 7) base += 2.0;  // 専7: 2.2 + 2.0 = 4.2個
          else if (ex >= 5) base += 1.0;  // 専5: 2.2 + 1.0 = 3.2個
          return base;
        }
      },
      'ノーラ': {
        type: '海軍',
        attackBuff: (ex) => 110 * exclusiveMultipliers[ex],
        // PSの衰弱付与（1ラウンドに1度）
        psDebuffValue: 30,
        psDebuffCount: (ex) => ex >= 5 ? 4 : 3,
        psDebuffRate: (ex) => ex >= 5 ? 44.4 : 33.3,
        // PSの脆弱付与（1ラウンドに1度、確率11.11%）
        psVulnerableValue: 30,
        psVulnerableCount: (ex) => ex >= 7 ? 4 : 3,
        psVulnerableLossCoef: 0.98,
        psVulnerableTriggerRate: 11.11 / 100,
        psVulnerableDamage: (ex) => {
          if (ex >= 7) return 40 + 265 + 200; // 505
          if (ex >= 5) return 40 + 180 + 139; // 359
          return 40 + 140 + 115; // 295
        },
        // グローバル効果
        globalDebuffBoost: (ex) => ex >= 5 ? 40 : 0,
        globalVulnerableBoost: (ex) => ex >= 5 ? 60 : 0,
        globalASDamageMultiplier: (ex) => ex >= 7 ? 1.12 : 1.0,
        specialHeroesASDamageMultiplier: (ex) => ex >= 7 ? 1.22 : 1.0,
        specialHeroes: ['ミーク', 'アイリス', 'ソフィ', 'ヒヨリ']
      },
      'ツバキ': {
        type: '海軍',
        attackBuff: (ex) => 108 * exclusiveMultipliers[ex],
        // PSの衰弱付与（1ラウンドに1度）
        psDebuffValue: 30,
        psDebuffCount: (ex) => ex >= 7 ? 4 : 3,
        psDebuffRate: (ex) => ex >= 7 ? 44.4 : 33.3,
        // グローバル効果
        globalDebuffBoost: (ex) => ex >= 5 ? 40 : 0,
        globalVulnerableBoost: (ex) => ex >= 5 ? 40 : 0,
        globalASDamageMultiplier: (ex) => ex >= 7 ? 1.12 : 1.0,
        specialHeroesASDamageMultiplier: (ex) => ex >= 7 ? 1.22 : 1.0,
        specialHeroes: ['ミーク', 'アイリス', 'ソフィ', 'ヒヨリ']
      },
      'ルネ': {
        type: '陸軍',
        ironWallValue: (ex) => (ex >= 7 ? 50 : 40) * exclusiveMultipliers[ex],
        ironWallRounds: (ex) => ex >= 5 ? 2 : 1,
        asRate: 33,
        asDamage: (ex) => 150 * exclusiveMultipliers[ex],
        asBullets: (ex) => ex >= 5 ? 4 : 3,
        magneticBulletsBonus: (ex) => ex >= 7 ? 1.0 : 0.5
      },
      'アカネ': {
        type: '陸軍',
        attackBuff: (ex) => 95 * exclusiveMultipliers[ex],
        magneticBoost: (ex) => ex >= 3 ? 110 : 20,
        asRate: 37,
        asDamage: (ex) => 55 * exclusiveMultipliers[ex],
        asBullets: 4,
        // AS拡散ダメ（複雑な計算が必要）
        asScatterDamage: (ex, magneticBulletsExpected, magneticHeroCount) => {
          const baseDamage = ex >= 7 ? 30 : 10;
          const adjustedMagnetic = magneticBulletsExpected / (1 + magneticHeroCount);
          const scatterMultiplier = Math.min(adjustedMagnetic * 9 / 13.3, 5);
          const scatterBullets = ex >= 5 ? 2 : 1;
          return { damage: baseDamage * scatterMultiplier, bullets: scatterBullets };
        },
        // PS磁気（専用7以上で各ラウンドに1度）
        psMagnetic: (ex) => ex >= 7 ? { value: 50, count: 6, rate: 0.11 } : null
      },
      'アリア＆ティナ': {
        type: '汎用',
        attackBuff: (ex) => 90 * exclusiveMultipliers[ex],
        asRate: (ex) => ex >= 5 ? 35 : 27,
        asDamage: (ex) => {
          const baseDamage = 130 * exclusiveMultipliers[ex];
          const bonusDamage = ex >= 7 ? 130 : 0;
          return baseDamage + bonusDamage;
        },
        asBullets: 3,
        // 脆弱の敵にAS命中時のダメージ変化（確率：脆弱数期待値／直接攻撃弾数期待値）
        asVulnerableBonus: 190,
        // PS脆弱付与（専5以上で1ラウンドに1度）
        psVulnerable: (ex) => {
          if (ex < 5) return null;
          const count = ex >= 7 ? 4 : 2;
          return { value: 30, count: count, rate: 0.11 };
        }
      },
      'フェルム': {
        type: '陸軍',
        attackBuff: (ex) => 90 * exclusiveMultipliers[ex],
        magneticBoost: (ex) => {
          if (ex >= 7) return 30 + 40 + 30; // 100
          if (ex >= 5) return 30 + 40; // 70
          return 30;
        },
        asRate: 42,
        asDamage: (ex) => {
          const baseDamage = 50 * exclusiveMultipliers[ex];
          const bonusDamage = ex >= 7 ? 30 : 0;
          return baseDamage + bonusDamage;
        },
        asBullets: 4,
        // PS磁気（専5以上で各ラウンドに1度）
        psMagnetic: (ex) => ex >= 5 ? { value: 60, count: 5, rate: 0.11 } : null
      },
      'カトレア': { name: '未実装', type: '陸軍' },
      'シャーリー': { name: '未実装', type: '陸軍' },
      'ミーチェ': { name: '未実装', type: '陸軍' },
      'ソフィ': {
        type: '海軍',
        shieldBuff: (ex) => 66 * exclusiveMultipliers[ex],
        asRate: 35,
        asDamage: (ex, hasAbnormalCombo) => {
          // 異常特攻: 状態異常種類数 × 特攻倍率
          const abnormalTypes = hasAbnormalCombo ? 1.3 : 0.4;
          const abnormalBonus = (ex >= 7 ? 25 : ex >= 5 ? 15 : 10) * Math.min(abnormalTypes, 3);
          return 130 * exclusiveMultipliers[ex] + abnormalBonus;
        },
        asBullets: (ex) => ex >= 7 ? 5 : 3,
        // PS：毎ターン脆弱属性ダメージ（付与ロス・期待値計算済み）
        psVulnerable: (ex) => {
          if (ex >= 7) return { count: 1.5, damage: 14.17 };
          if (ex >= 5) return { count: 1.5, damage: 7.43 };
          return { count: 1.0, damage: 8.77 };
        }
      },
      'ヒヨリ': {
        type: '海軍',
        shieldBuff: (ex) => 65 * exclusiveMultipliers[ex],
        asRate: 35,
        asDamage: (ex, hasAbnormalCombo) => {
          const abnormalBonus = ex >= 7 ? 50 : ex >= 5 ? 30 : 10;
          return 130 * exclusiveMultipliers[ex] + abnormalBonus;
        },
        asBullets: (ex) => ex >= 7 ? 5 : 3,
        // PS：毎ターン脆弱属性ダメージ
        psVulnerable: (ex) => {
          if (ex >= 7) return { count: 1.5, damage: 10.63 };
          if (ex >= 5) return { count: 1.5, damage: 5.57 };
          return { count: 1.0, damage: 8.77 };
        }
      },
      'ミーク': {
        type: '海軍',
        ironWallValue: (ex) => (ex >= 7 ? 50 : 40) * exclusiveMultipliers[ex],
        ironWallRounds: (ex) => ex >= 5 ? 2 : 1,
        asRate: 35,
        asDamage: (ex) => (ex >= 5 ? 115 : 90) * exclusiveMultipliers[ex],
        asBullets: (ex) => ex >= 7 ? 4.5 : 3,
        // AS衰弱効果
        asDebuff: (ex, hasRush, silenceCount) => {
          const actualRate = 35 * (9 - silenceCount) / 9 / 100;
          const baseRate = 35 / 100;
          const baseDebuffRate = ex >= 7 ? (hasRush ? 86.3 : 81.4) : (hasRush ? 80.3 : 69.8);
          const adjustedRate = baseDebuffRate * Math.sqrt(actualRate / baseRate) / 100;
          return { value: 15 * exclusiveMultipliers[ex], rate: adjustedRate };
        },
        // AS重甲付与
        asArmor: { count: 1.5, value: 15 }
      },
      'アイリス': {
        type: '海軍',
        ironWallValue: (ex) => (ex >= 7 ? 50 : 40) * exclusiveMultipliers[ex],
        ironWallRounds: (ex) => ex >= 5 ? 2 : 1,
        asRate: 35,
        asDamage: (ex) => 95 * exclusiveMultipliers[ex],
        asBullets: (ex) => ex >= 7 ? 5 : 3,
        // AS衰弱効果
        asDebuff: (ex, hasRush, silenceCount) => {
          const actualRate = 35 * (9 - silenceCount) / 9 / 100;
          const baseRate = 35 / 100;
          const baseDebuffRate = ex >= 5 ? (hasRush ? 86.3 : 81.4) : (hasRush ? 80.3 : 69.8);
          // 四乗根で調整（√√）
          const adjustedRate = baseDebuffRate * Math.pow(actualRate / baseRate, 0.25) / 100;
          return { value: 15 * exclusiveMultipliers[ex], rate: adjustedRate };
        },
        // AS重甲付与
        asArmor: { count: 3, value: 15 }
      },
      'レイチェル': { name: '未実装', type: '海軍' },
      'コレット': { name: '未実装', type: '海軍' },
      'リヴィア': { name: '未実装', type: '空軍' },
      'ルチル': { name: '未実装', type: '空軍' },
      'ノルシュ': { name: '未実装', type: '空軍' },
      'ギャビー': { name: '未実装', type: '空軍' },
      'ビスコット': { name: '未実装', type: '空軍' },
      'フローリア': { name: '未実装', type: '空軍' }
    };

    const presets = {
      1: ['ペトラ', 'ミヤ', 'ルネ'],
      2: ['カトレア', 'シャーリー', 'ミーチェ'],
      3: ['ノーラ', 'ソフィ', 'ミーク'],
      4: ['レイチェル', 'コレット', 'アイリス'],
      5: ['リヴィア', 'ルチル', 'ノルシュ'],
      6: ['ギャビー', 'ビスコット', 'フローリア']
    };

    const titanEffects = {
      rifle: {
        effects: [
          { name: '戦場洞察', desc: 'ダメ増バフ加算', levels: [10, 15, 20, 25, 30, 35, 40] },
          { name: '衝撃', desc: '衰弱付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '灼熱', desc: '燃焼付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '磁場', desc: '磁気付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '破凱', desc: '脆弱付与', levels: [15, 30, 30], counts: [1, 1, 2], lossCoefs: [0.98, 0.98, 0.95] },
          { name: '砲撃の嵐', desc: '攻撃強化の強化', levels: [4, 7, 11, 15, 19, 23, 30] },
          { name: '全軍突撃', desc: 'R1のみ追撃２回発動', levels: [15, 18, 22, 27, 33, 40, 50] }
        ]
      },
      armor: {
        effects: [
          { name: '補足不能', desc: 'ダメ減バフ加算', levels: [10, 15, 20, 25, 30, 35, 40] },
          { name: '振動', desc: '衰弱強化', levels: [15, 22, 30] },
          { name: '点火', desc: '燃焼強化', levels: [15, 22, 30] },
          { name: '着磁', desc: '磁気強化', levels: [15, 22, 30] },
          { name: '重撃', desc: '脆弱強化', levels: [15, 22, 30] },
          { name: '重甲', desc: '敵追撃ダメ軽減', levels: [15, 22, 30], counts: [1, 1.5, 2] },
          { name: '鋼の奔流', desc: '開戦シールドの強化', levels: [4, 7, 11, 15, 19, 23, 30] },
          { name: '破壊不能', desc: '鉄壁１ラウンド追加', levels: [15, 18, 22, 27, 33, 40, 50] }
        ]
      },
      vision: {
        effects: [
          { name: '戦場洞察', desc: 'ダメ増バフ加算', levels: [10, 15, 20, 25, 30, 35, 40] },
          { name: '衝撃', desc: '衰弱付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '灼熱', desc: '燃焼付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '磁場', desc: '磁気付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '破凱', desc: '脆弱付与', levels: [15, 30, 30], counts: [1, 1, 2], lossCoefs: [0.98, 0.98, 0.95] }
        ]
      },
      head: {
        effects: [
          { name: '補足不能', desc: 'ダメ減バフ加算', levels: [10, 15, 20, 25, 30, 35, 40] },
          { name: '振動', desc: '衰弱強化', levels: [15, 22, 30] },
          { name: '点火', desc: '燃焼強化', levels: [15, 22, 30] },
          { name: '着磁', desc: '磁気強化', levels: [15, 22, 30] },
          { name: '重撃', desc: '脆弱強化', levels: [15, 22, 30] }
        ]
      },
      handy: {
        effects: [
          { name: '戦場洞察', desc: 'ダメ増バフ加算', levels: [10, 15, 20, 25, 30, 35, 40] },
          { name: '衝撃', desc: '衰弱付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '灼熱', desc: '燃焼付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '磁場', desc: '磁気付与', levels: [15, 30, 30], counts: [1, 1, 2] },
          { name: '破凱', desc: '脆弱付与', levels: [15, 30, 30], counts: [1, 1, 2], lossCoefs: [0.98, 0.98, 0.95] }
        ]
      },
      boots: {
        effects: [
          { name: '補足不能', desc: 'ダメ減バフ加算', levels: [10, 15, 20, 25, 30, 35, 40] },
          { name: '振動', desc: '衰弱強化', levels: [15, 22, 30] },
          { name: '点火', desc: '燃焼強化', levels: [15, 22, 30] },
          { name: '着磁', desc: '磁気強化', levels: [15, 22, 30] },
          { name: '重撃', desc: '脆弱強化', levels: [15, 22, 30] }
        ]
      }
    };

    const slotNames = ['rifle', 'armor', 'vision', 'head', 'handy', 'boots'];
    const slotDisplayNames = ['ライフル', 'アーマー', '視野', 'ヘッド', 'ハンディ', 'ブーツ'];

    function GameCalculator() {
      const [buffs, setBuffs] = useState({
        troops: 200,
        soldierLv: 103,
        life: 3000,
        attack: 3000,
        damageIncrease: 400,
        damageReduction: 400,
        defense: 140,
        typeAdvantage: 120,
        baseShield: 28,
        silenceCount: 0,
        enemyIronWall: '専用5',
        powerDiff: 1.0,
        enemyRushRatio: 0.15,
        enemyPowerDurabilityRatio: 0.3,
        myPowerDurabilityRatio: 0.3
      });

      const [compatibility, setCompatibility] = useState('同兵種');
      const [titanEnabled, setTitanEnabled] = useState(true);
      
      // ラウンド重み係数
      const [powerRoundWeights, setPowerRoundWeights] = useState(getDefaultPowerRoundWeights('専用5'));
      const [durabilityRoundWeights, setDurabilityRoundWeights] = useState(defaultDurabilityRoundWeights);
      
      // 敵の火力/耐久比に応じて火力ラウンド重み係数を調整する関数
      const adjustPowerWeightsByRatio = (baseWeights, ratio) => {
        // ratio: 0.1～0.5 (デフォルト0.3)
        // 0.3の時はbaseWeightsそのまま
        // 0に近づくほど [0,0,0,1] に近づく（線形補正）
        // 1に近づくほどR4が0に近づき、他が比率維持して上昇
        
        if (ratio === 0.3) return baseWeights;
        
        const target0 = [0, 0, 0, 1]; // ratio=0のターゲット
        
        if (ratio < 0.3) {
          // 0から0.3の間: 線形補間
          const t = ratio / 0.3; // 0～1
          return baseWeights.map((w, i) => w * t + target0[i] * (1 - t));
        } else {
          // 0.3から上: R4を減らし、他を比率維持して増加
          // ratio=1でR4=0を目指す
          const t = (ratio - 0.3) / (0.5 - 0.3); // 0～1 (0.3～0.5で正規化)
          const clampedT = Math.max(0, Math.min(1, t));
          
          // R4を減らす
          const newR4 = baseWeights[3] * (1 - clampedT);
          
          // R1,R2,R3の合計を求める
          const r123Sum = baseWeights[0] + baseWeights[1] + baseWeights[2];
          
          // 減った分を比率維持してR1,R2,R3に分配
          const addAmount = baseWeights[3] * clampedT;
          const newR1 = baseWeights[0] + (baseWeights[0] / r123Sum) * addAmount;
          const newR2 = baseWeights[1] + (baseWeights[1] / r123Sum) * addAmount;
          const newR3 = baseWeights[2] + (baseWeights[2] / r123Sum) * addAmount;
          
          return [newR1, newR2, newR3, newR4];
        }
      };
      
      // 敵の鉄壁条件または火力/耐久比が変更されたら火力ラウンド重み係数を自動更新
      React.useEffect(() => {
        const baseWeights = getDefaultPowerRoundWeights(buffs.enemyIronWall);
        const adjustedWeights = adjustPowerWeightsByRatio(baseWeights, buffs.enemyPowerDurabilityRatio);
        setPowerRoundWeights(adjustedWeights);
      }, [buffs.enemyIronWall, buffs.enemyPowerDurabilityRatio]);
      
      // タブ折りたたみ状態
      const [expandedTabs, setExpandedTabs] = useState({
        buffs: true,
        environment: true,
        heroes: true,
        titanEquip: true,
        buffCalc: true,
        heroCalc: true,
        totalEval: true
      });
      
      // 英雄ごとのタイタン装備折りたたみ状態
      const [expandedTitanHeroes, setExpandedTitanHeroes] = useState({
        0: true,
        1: true,
        2: true
      });
      
      const toggleTab = (tabName) => {
        setExpandedTabs(prev => ({...prev, [tabName]: !prev[tabName]}));
      };
      
      const toggleTitanHero = (heroIndex) => {
        setExpandedTitanHeroes(prev => ({...prev, [heroIndex]: !prev[heroIndex]}));
      };

      const [heroes, setHeroes] = useState([
        { name: 'ペトラ', exclusiveLv: 0 },
        { name: 'ミヤ', exclusiveLv: 0 },
        { name: 'ルネ', exclusiveLv: 0 }
      ]);

      const [titanEquip, setTitanEquip] = useState(
        heroes.map(() => slotNames.map(() => ({ effect: '', level: 1 })))
      );

      const numericBuffKeys = new Set([
        'troops', 'soldierLv', 'life', 'attack', 'damageIncrease', 'damageReduction',
        'defense', 'typeAdvantage', 'baseShield', 'silenceCount',
        'powerDiff', 'enemyRushRatio', 'enemyPowerDurabilityRatio', 'myPowerDurabilityRatio'
      ]);
      
      const updateBuff = (key, value) => {
        if (numericBuffKeys.has(key)) {
          const parsed = parseFloat(value);
          // null/空/変換不能な場合は0をセット
          setBuffs(prev => ({ ...prev, [key]: isNaN(parsed) ? 0 : parsed }));
        } else {
          // 文字列フィールド（enemyIronWallなど）はそのまま保存
          setBuffs(prev => ({ ...prev, [key]: value }));
        }
      };

      const selectPreset = (presetNum) => {
        const newHeroes = presets[presetNum].map(name => ({ name, exclusiveLv: 0 }));
        setHeroes(newHeroes);
        setTitanEquip(newHeroes.map(() => slotNames.map(() => ({ effect: '', level: 1 }))));
      };

      const updateHero = (index, field, value) => {
        setHeroes(prev => {
          const newHeroes = [...prev];
          newHeroes[index] = { ...newHeroes[index], [field]: value };
          return newHeroes;
        });
      };

      const updateTitan = (heroIndex, slotIndex, field, value) => {
        setTitanEquip(prev => {
          const newEquip = [...prev];
          newEquip[heroIndex] = [...newEquip[heroIndex]];
          newEquip[heroIndex][slotIndex] = {
            ...newEquip[heroIndex][slotIndex],
            [field]: value
          };
          return newEquip;
        });
      };

      // 計算処理
      const calculations = useMemo(() => {
        // 兵種の不一致チェック（外す・未実装を除く有効な英雄のみ）
        const heroTypes = heroes
          .filter(h => h.name !== '外す' && heroData[h.name] && !heroData[h.name].name)
          .map(h => heroData[h.name].type)
          .filter(t => t && t !== '汎用');
        const uniqueTypes = [...new Set(heroTypes)];
        const typeWarning = uniqueTypes.length > 1 ? '⚠️ 英雄の兵種が異なります（混成編成）' : '';

        const soldier = soldierData[buffs.soldierLv];
        
        // バフ相性計算
        const compatDurability = (buffs.life + 100) / 100 * (buffs.damageReduction + 100) / 100 * (buffs.defense + 100) / 100;
        
        let compatPower = (buffs.attack + 100) / 100 * (buffs.damageIncrease + 100) / 100;
        if (compatibility === '有利') {
          compatPower = (buffs.attack + 100 + buffs.typeAdvantage) / 100 * (buffs.damageIncrease + 100) / 100;
        } else if (compatibility === '不利') {
          compatPower = compatPower / (1 + buffs.typeAdvantage / 100);
        }
        
        const compatStrength = compatPower * compatDurability;
        const compatTroopDurability = compatDurability * buffs.troops;
        const compatTroopPower = compatPower * buffs.troops;
        const compatTroopStrength = compatTroopDurability * compatTroopPower;
        const compatTroopSoldierDurability = compatTroopDurability * soldier.durability * 1000000000; // 1B掛ける
        const compatTroopSoldierPower = compatTroopPower * soldier.power * 1000000000; // 1B掛ける
        // 強さ値は1B^2がかからないように計算
        const compatTroopSoldierStrength = (compatTroopSoldierDurability / 1000000000) * (compatTroopSoldierPower / 1000000000);

        // タイタン効果の計算（ON/OFF両方）
        const calculateHeroStats = (useTitan) => {
          let totalAttackBuff = 0;
          let totalShieldBuff = buffs.baseShield;
          let totalASDamage = 0;
          
          // 直接ダメージ追跡（脆弱計算用）
          let totalDirectDamage = 0;
          let totalDirectBullets = 0;
          
          // 脆弱ダメージ追跡（脆弱属性）
          let totalVulnerableDamage = 0;
          
          // AS弾数追跡（追撃火力比率計算用）
          let totalASBullets = 0;
          
          // 通常攻撃の兵種別計算
          const getBasicAttack = () => {
            const types = heroes.map(h => heroData[h.name]?.type).filter(t => t && t !== '汎用');
            const uniqueTypes = [...new Set(types)];
            
            // 海軍のみ、空軍のみ、海軍と汎用のみ、空軍と汎用のみ
            if (uniqueTypes.length === 1 && (uniqueTypes[0] === '海軍' || uniqueTypes[0] === '空軍')) {
              totalDirectBullets += 3;
              return 40 * 3; // 120%
            }
            // 陸軍のみ、陸軍と汎用のみ
            if (uniqueTypes.length === 1 && uniqueTypes[0] === '陸軍') {
              totalDirectBullets += 1;
              return 117 * 1; // 117%
            }
            // その他
            totalDirectBullets += 2.3;
            return 50 * 2.3; // 115%
          };
          
          const basicAttackDamage = getBasicAttack();
          totalDirectDamage += basicAttackDamage;
          let totalPSDamage = basicAttackDamage;
          let maxIronWall = 0;
          let maxIronWallExLv = 0;
          let hasIronWall = false;
          let totalInsightValue = 0;
          let totalElusivenessValue = 0;

          const artilleryBoosts = heroes.map((hero, i) => {
            if (!useTitan) return 0;
            let boost = 0;
            titanEquip[i].forEach((equip, slotIdx) => {
              if (equip.effect === '砲撃の嵐') {
                const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '砲撃の嵐');
                if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                  boost += effect.levels[equip.level - 1];
                }
              }
            });
            return boost;
          });

          const steelBoosts = heroes.map((hero, i) => {
            if (!useTitan) return 0;
            let boost = 0;
            titanEquip[i].forEach((equip, slotIdx) => {
              if (equip.effect === '鋼の奔流') {
                const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '鋼の奔流');
                if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                  boost += effect.levels[equip.level - 1];
                }
              }
            });
            return boost;
          });

          // グローバル磁気効果強化（全英雄の磁気に適用）
          let globalMagneticBoost = 0;
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (data && data.magneticBoost) {
              globalMagneticBoost += data.magneticBoost(hero.exclusiveLv);
            }
          });

          // グローバル燃焼効果強化（全英雄の燃焼に適用）
          let globalBurningBoost = 0;
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (data && data.burningBoost) {
              globalBurningBoost += data.burningBoost(hero.exclusiveLv);
            }
          });

          // グローバル衰弱効果強化（ノーラ専用5以上で+40%）
          let globalDebuffBoost = 0;
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (data && data.globalDebuffBoost) {
              globalDebuffBoost += data.globalDebuffBoost(hero.exclusiveLv);
            }
          });

          // グローバル脆弱効果強化（ノーラ専用5以上で+60%）
          let globalVulnerableBoost = 0;
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (data && data.globalVulnerableBoost) {
              globalVulnerableBoost += data.globalVulnerableBoost(hero.exclusiveLv);
            }
          });

          // グローバルASダメージ倍率（ノーラ専用7以上で適用）
          let noraASDamageMultiplier = 1.0;
          let noraSpecialMultiplier = 1.0;
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (data && data.globalASDamageMultiplier) {
              const mult = data.globalASDamageMultiplier(hero.exclusiveLv);
              if (mult > noraASDamageMultiplier) {
                noraASDamageMultiplier = mult;
              }
            }
            if (data && data.specialHeroesASDamageMultiplier) {
              const mult = data.specialHeroesASDamageMultiplier(hero.exclusiveLv);
              if (mult > noraSpecialMultiplier) {
                noraSpecialMultiplier = mult;
              }
            }
          });
          const noraSpecialHeroes = heroes.some(h => {
            const data = heroData[h.name];
            return data && data.specialHeroes;
          }) ? heroData[heroes.find(h => heroData[h.name]?.specialHeroes)?.name]?.specialHeroes || [] : [];


          // ローカル磁気効果強化（装備した英雄のみに適用）
          const localMagneticBoosts = heroes.map((hero, i) => {
            let boost = 0;
            if (useTitan) {
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '着磁' && ['armor', 'head', 'boots'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '着磁');
                  if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                    boost += effect.levels[equip.level - 1];
                  }
                }
              });
            }
            return boost;
          });

          // ローカル燃焼効果強化（装備した英雄のみに適用）
          const localBurningBoosts = heroes.map((hero, i) => {
            let boost = 0;
            if (useTitan) {
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '点火' && ['armor', 'head', 'boots'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '点火');
                  if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                    boost += effect.levels[equip.level - 1];
                  }
                }
              });
            }
            return boost;
          });

          // ローカル衰弱効果強化（装備した英雄のみに適用）
          const localWeakenBoosts = heroes.map((hero, i) => {
            let boost = 0;
            if (useTitan) {
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '振動' && ['armor', 'head', 'boots'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '振動');
                  if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                    boost += effect.levels[equip.level - 1];
                  }
                }
              });
            }
            return boost;
          });

          // ローカル脆弱効果強化（装備した英雄のみに適用）
          const localVulnerBoosts = heroes.map((hero, i) => {
            let boost = 0;
            if (useTitan) {
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '重撃' && ['armor', 'head', 'boots'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '重撃');
                  if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                    boost += effect.levels[equip.level - 1];
                  }
                }
              });
            }
            return boost;
          });

          // 戦場洞察と補足不能の合計値を計算
          if (useTitan) {
            heroes.forEach((hero, i) => {
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '戦場洞察') {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '戦場洞察');
                  if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                    totalInsightValue += effect.levels[equip.level - 1];
                  }
                }
                if (equip.effect === '補足不能') {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '補足不能');
                  if (effect && effect.levels && effect.levels[equip.level - 1] !== undefined) {
                    totalElusivenessValue += effect.levels[equip.level - 1];
                  }
                }
              });
            });
          }

          let runeMagneticBonus = 0;
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (hero.name === 'ルネ' && data && data.magneticBulletsBonus) {
              runeMagneticBonus = data.magneticBulletsBonus(hero.exclusiveLv);
            }
          });

          const hasCombo = heroes.some(h => h.name === 'ペトラ') && heroes.some(h => h.name === 'ミヤ');

          // 磁気数期待値の集計（アカネのAS拡散ダメ計算用）
          let totalMagneticBulletsExpected = 0;
          const magneticHeroCount = heroes.filter(h => ['フェルム', 'アカネ', 'ペトラ', 'アスカ'].includes(h.name)).length - 1; // 自分を除く
          
          // 脆弱数期待値の集計（アリア＆ティナのASボーナス計算用）
          let totalVulnerableBulletsExpected = 0;

          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (!data || data.name === '未実装' || data.name === '外す') return;

            const exLv = hero.exclusiveLv;
            
            if (data.attackBuff) {
              const attackBoost = data.attackBuff(exLv);
              totalAttackBuff += attackBoost * (100 + artilleryBoosts[i]) / 100;
            }

            if (data.shieldBuff) {
              const shieldBoost = data.shieldBuff(exLv);
              totalShieldBuff += shieldBoost * (100 + steelBoosts[i]) / 100;
            }

            if (data.ironWallValue) {
              hasIronWall = true;
              const ironValue = data.ironWallValue(exLv);
              if (ironValue > maxIronWall) {
                maxIronWall = ironValue;
                maxIronWallExLv = exLv;
              }
            }

            if (data.asRate && data.asDamage && data.asBullets) {
              // AS発動率の取得（アリア＆ティナは専用レベルに応じて変化）
              const baseRate = typeof data.asRate === 'function' ? data.asRate(exLv) : data.asRate;
              const actualRate = baseRate * (9 - buffs.silenceCount) / 9 / 100;
              const bullets = typeof data.asBullets === 'function' ? data.asBullets(exLv) : data.asBullets;
              
              // ソフィ・ヒヨリの異常特攻判定
              const hasAbnormalCombo = (hero.name === 'ソフィ' || hero.name === 'ヒヨリ') &&
                heroes.some(h => h.name === 'アイリス' || h.name === 'ミーク');
              const damage = typeof data.asDamage === 'function' 
                ? (data.asDamage.length >= 2 ? data.asDamage(exLv, hasAbnormalCombo) : data.asDamage(exLv))
                : data.asDamage;
              
              // ノーラのグローバルASダメージ倍率を適用（直接ダメージ部分のみ）
              let asDamageMultiplier = 1.0;
              if (noraSpecialHeroes.includes(hero.name)) {
                asDamageMultiplier = noraSpecialMultiplier;
              } else {
                asDamageMultiplier = noraASDamageMultiplier;
              }
              
              // アリア＆ティナの脆弱ボーナス計算
              let finalDamage = damage;
              if (hero.name === 'アリア＆ティナ' && data.asVulnerableBonus) {
                const vulnerableProb = totalDirectBullets > 0 ? totalVulnerableBulletsExpected / totalDirectBullets : 0;
                const normalDamage = damage;
                const bonusDamage = data.asVulnerableBonus;
                finalDamage = normalDamage * (1 - vulnerableProb) + bonusDamage * vulnerableProb;
              }
              
              const asDamageAmount = actualRate * finalDamage * bullets * asDamageMultiplier;
              totalASDamage += asDamageAmount;
              
              // 直接ダメージとして追跡
              totalDirectDamage += asDamageAmount;
              totalDirectBullets += actualRate * bullets;
              totalASBullets += actualRate * bullets;

              if (hero.name === 'ペトラ' && data.asExtraEffect) {
                const extra = data.asExtraEffect(exLv, hasCombo);
                if (extra) {
                  // ルネボーナスを適用した弾数係数
                  const bulletCoefficient = 1.5 + runeMagneticBonus;
                  const adjustedBullets = (exLv >= 5 ? 5 : 4) * 0.5 * bulletCoefficient;
                  const magneticBoost = 100 + globalMagneticBoost + localMagneticBoosts[i];
                  const extraDamage = actualRate * extra.damage * adjustedBullets * magneticBoost / 100;
                  totalASDamage += extraDamage;
                  // ペトラの追加磁気は磁気属性なので直接ダメージには含めない
                  
                  // ペトラの磁気数を集計
                  totalMagneticBulletsExpected += actualRate * adjustedBullets;
                }
              }
              
              // アカネのAS拡散ダメ
              if (hero.name === 'アカネ' && data.asScatterDamage) {
                const baseRate = typeof data.asRate === 'function' ? data.asRate(exLv) : data.asRate;
                const actualRate = baseRate * (9 - buffs.silenceCount) / 9 / 100;
                const scatterInfo = data.asScatterDamage(exLv, totalMagneticBulletsExpected, magneticHeroCount);
                const scatterDamage = actualRate * scatterInfo.damage * scatterInfo.bullets * asDamageMultiplier;
                totalASDamage += scatterDamage;
                totalDirectDamage += scatterDamage;
                totalDirectBullets += actualRate * scatterInfo.bullets;
              }
            }
            
            // アカネ・フェルムのPS磁気
            if (data.psMagnetic) {
              const psInfo = data.psMagnetic(exLv);
              if (psInfo) {
                const magneticBoost = 100 + globalMagneticBoost + localMagneticBoosts[i];
                const psMagneticDamage = psInfo.rate * psInfo.value * psInfo.count * magneticBoost / 100;
                totalASDamage += psMagneticDamage;
                // 磁気数を集計
                totalMagneticBulletsExpected += psInfo.rate * psInfo.count;
              }
            }

            if (data.psMagneticDamage && data.psMagneticBullets) {
              const bullets = typeof data.psMagneticBullets === 'function' ? 
                data.psMagneticBullets(exLv) + runeMagneticBonus : 
                data.psMagneticBullets + runeMagneticBonus;
              const damage = typeof data.psMagneticDamage === 'function' ?
                data.psMagneticDamage(exLv) :
                data.psMagneticDamage;
              const magneticBoost = 100 + globalMagneticBoost + localMagneticBoosts[i];
              totalPSDamage += damage * bullets * magneticBoost / 100;
              // ミヤの磁気数を集計
              totalMagneticBulletsExpected += bullets;
            }
          });

          // 磁場（磁気付与）などの付与系効果はAS総ダメージに計上（ASトリガー）
          // 衰弱効果の収集（耐久計算用）
          const debuffEffects = [];
          
          if (useTitan) {
            heroes.forEach((hero, i) => {
              const data = heroData[hero.name];
              if (!data || data.name === '未実装' || data.name === '外す') return;

              let asRate = 0;
              if (data.asRate) {
                asRate = data.asRate * (9 - buffs.silenceCount) / 9 / 100;
              }

              // 全軍突撃の有無を確認
              let hasRush = false;
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '全軍突撃' && slotNames[slotIdx] === 'rifle') {
                  hasRush = true;
                }
              });

              // 衝撃（衰弱付与）効果を収集（タイタン装備）
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '衝撃' && ['rifle', 'vision', 'handy'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '衝撃');
                  if (effect && effect.levels && effect.counts) {
                    const weakenValue = effect.levels[equip.level - 1];
                    const weakenCount = effect.counts[equip.level - 1];
                    const weakenBoost = 100 + localWeakenBoosts[i] + globalDebuffBoost;
                    const debuffRate = getDebuffRate(asRate, weakenCount, hasRush);
                    const enhancedValue = weakenValue * weakenBoost / 100;
                    debuffEffects.push({ value: enhancedValue, rate: debuffRate });
                  }
                }
              });
            });
          }

          // 英雄固有の衰弱スキル（タイタンON/OFFに関わらず適用）
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (!data || data.name === '未実装' || data.name === '外す') return;

            const exLv = hero.exclusiveLv;
            const baseRate = data.asRate ? (typeof data.asRate === 'function' ? data.asRate(exLv) : data.asRate) : 0;
            let asRate = baseRate * (9 - buffs.silenceCount) / 9 / 100;

            // 全軍突撃の有無を確認（タイタンON時のみ）
            let hasRush = false;
            if (useTitan) {
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '全軍突撃' && slotNames[slotIdx] === 'rifle') hasRush = true;
              });
            }

            // ノーラのPS衰弱付与
            if (hero.name === 'ノーラ' && data.psDebuffValue) {
              const debuffRate = data.psDebuffRate(exLv) / 100;
              const enhancedValue = data.psDebuffValue * (100 + globalDebuffBoost) / 100;
              debuffEffects.push({ value: enhancedValue, rate: debuffRate });
            }

            // ツバキのPS衰弱付与
            if (hero.name === 'ツバキ' && data.psDebuffValue) {
              const debuffRate = data.psDebuffRate(exLv) / 100;
              const enhancedValue = data.psDebuffValue * (100 + globalDebuffBoost) / 100;
              debuffEffects.push({ value: enhancedValue, rate: debuffRate });
            }

            // ミーク・アイリスのAS衰弱付与
            if ((hero.name === 'ミーク' || hero.name === 'アイリス') && data.asDebuff) {
              const debuffInfo = data.asDebuff(exLv, hasRush, buffs.silenceCount);
              const enhancedValue = debuffInfo.value * (100 + globalDebuffBoost) / 100;
              debuffEffects.push({ value: enhancedValue, rate: debuffInfo.rate });
            }
          });

          // 衰弱耐久補正の計算（二項分布的な重複処理）
          let debuffDurabilityCorrection = 1.0;
          
          if (debuffEffects.length > 0) {
            // E[F] = Σ (∏(i∈S) Pi ∏(j∉S) (1-Pj) · 1/(1 + Σ(k∈S) Dk))
            // すべての組み合わせ（2^n通り）を計算
            const n = debuffEffects.length;
            let expectedEnemyPower = 0;
            
            for (let mask = 0; mask < (1 << n); mask++) {
              let probability = 1.0;
              let totalDebuffValue = 0;
              
              for (let i = 0; i < n; i++) {
                if (mask & (1 << i)) {
                  // この衰弱が適用される
                  probability *= debuffEffects[i].rate;
                  totalDebuffValue += debuffEffects[i].value;
                } else {
                  // この衰弱が適用されない
                  probability *= (1 - debuffEffects[i].rate);
                }
              }
              
              // この組み合わせでの敵火力
              const enemyPowerMultiplier = 1 / (1 + totalDebuffValue / 100);
              expectedEnemyPower += probability * enemyPowerMultiplier;
            }
            
            // 衰弱耐久補正 = 1 / E[F]
            debuffDurabilityCorrection = 1 / expectedEnemyPower;
          }

          // 重甲耐久補正の計算
          // 重甲耐久補正 = 1 + 敵追撃期待値 × (重甲値% / 100%) × 重甲枚数期待値
          let armorDurabilityCorrection = 1.0;
          const enemyRushExpected = buffs.enemyRushRatio;
          
          // タイタン装備の重甲を集計
          let totalArmorValue = 0;
          let totalArmorCount = 0;
          if (useTitan) {
            heroes.forEach((hero, i) => {
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '重甲' && slotNames[slotIdx] === 'armor') {
                  const effect = titanEffects['armor'].effects.find(e => e.name === '重甲');
                  if (effect && effect.levels && effect.counts) {
                    totalArmorValue += effect.levels[equip.level - 1];
                    totalArmorCount += effect.counts[equip.level - 1];
                  }
                }
              });
            });
          }
          
          // ミーク・アイリスのAS重甲付与
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (!data || data.name === '未実装' || data.name === '外す') return;
            if (data.asArmor) {
              const exLv = hero.exclusiveLv;
              const actualRate = data.asRate ? data.asRate * (9 - buffs.silenceCount) / 9 / 100 : 0;
              // 期待重甲枚数 = 発動率 × 付与数
              totalArmorValue += data.asArmor.value;
              totalArmorCount += actualRate * data.asArmor.count;
            }
          });
          
          if (totalArmorCount > 0 && totalArmorValue > 0) {
            armorDurabilityCorrection = 1 + enemyRushExpected * (totalArmorValue / 100) * totalArmorCount;
          }
          
          // 衰弱等耐久補正 = 衰弱耐久補正 × 重甲耐久補正 × その他耐久補正
          const totalDebuffDurabilityCorrection = debuffDurabilityCorrection * armorDurabilityCorrection;
          if (useTitan) {
            heroes.forEach((hero, i) => {
              const data = heroData[hero.name];
              if (!data || data.name === '未実装' || data.name === '外す') return;

              // 実際のAS発動率
              let asRate = 0;
              if (data.asRate) {
                asRate = data.asRate * (9 - buffs.silenceCount) / 9 / 100;
              }

              titanEquip[i].forEach((equip, slotIdx) => {
                // 磁場（磁気付与）
                if (equip.effect === '磁場' && ['rifle', 'vision', 'handy'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '磁場');
                  if (effect && effect.levels && effect.counts) {
                    const magneticValue = effect.levels[equip.level - 1];
                    const magneticCount = effect.counts[equip.level - 1];
                    const magneticBoost = 100 + globalMagneticBoost + localMagneticBoosts[i];
                    totalASDamage += asRate * magneticValue * magneticCount * magneticBoost / 100;
                    // 磁気数期待値を集計
                    totalMagneticBulletsExpected += asRate * magneticCount;
                  }
                }
                
                // 灼熱（燃焼付与）
                if (equip.effect === '灼熱' && ['rifle', 'vision', 'handy'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '灼熱');
                  if (effect && effect.levels && effect.counts) {
                    const burningValue = effect.levels[equip.level - 1];
                    const burningCount = effect.counts[equip.level - 1];
                    const burningBoost = 100 + globalBurningBoost + localBurningBoosts[i];
                    totalASDamage += asRate * burningValue * burningCount * burningBoost / 100;
                  }
                }

                // 破凱（脆弱付与）- 脆弱属性のダメージ
                if (equip.effect === '破凱' && ['rifle', 'vision', 'handy'].includes(slotNames[slotIdx])) {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '破凱');
                  if (effect && effect.levels && effect.counts && effect.lossCoefs) {
                    const vulnerValue = effect.levels[equip.level - 1];
                    const vulnerCount = effect.counts[equip.level - 1];
                    const lossCoef = effect.lossCoefs[equip.level - 1];
                    const vulnerBoost = 100 + localVulnerBoosts[i] + globalVulnerableBoost;
                    
                    // 脆弱ダメージ = (脆弱を含まない直接攻撃火力 / 直接攻撃弾数) × (脆弱値 / 100%) × (付与数 × ロス係数) × 脆弱強化
                    // これはASトリガーなので実際AS発動率を掛ける
                    const vulnerDamage = asRate * (totalDirectDamage / (totalDirectBullets || 1)) * 
                                        (vulnerValue / 100) * (vulnerCount * (lossCoef * 0.95)) * 
                                        (vulnerBoost / 100);
                    totalASDamage += vulnerDamage;
                    // 脆弱ダメージは脆弱属性として別途追跡（弾数はカウントしない）
                    totalVulnerableDamage += vulnerDamage;
                    // 脆弱数期待値を集計
                    totalVulnerableBulletsExpected += asRate * vulnerCount * lossCoef * 0.95;
                  }
                }
              });
            });
          }

          // 英雄固有のPS脆弱ダメージ（タイタンON/OFFに関わらず適用）
          heroes.forEach((hero, i) => {
            const data = heroData[hero.name];
            if (!data || data.name === '未実装' || data.name === '外す') return;
            const exLv = hero.exclusiveLv;

            // ノーラのPS脆弱付与（1ラウンドに1度、確率11.11%）
            if (hero.name === 'ノーラ' && data.psVulnerableValue) {
              const vulnerValue = data.psVulnerableValue;
              const triggerRate = data.psVulnerableTriggerRate;
              const baseDamage = data.psVulnerableDamage(exLv);
              const vulnerBoost = 100 + globalVulnerableBoost;
              const nolaPSVulnerDamage = baseDamage * (vulnerValue / 100) * (vulnerBoost / 100) * triggerRate;
              totalASDamage += nolaPSVulnerDamage;
              totalVulnerableDamage += nolaPSVulnerDamage;
            }

            // ソフィ・ヒヨリのPS脆弱ダメージ（毎ターン、期待値計算済み）
            if ((hero.name === 'ソフィ' || hero.name === 'ヒヨリ') && data.psVulnerable) {
              const psInfo = data.psVulnerable(exLv);
              const vulnerBoost = 100 + globalVulnerableBoost;
              const psvulnerDamage = psInfo.count * psInfo.damage * (vulnerBoost / 100);
              totalASDamage += psvulnerDamage;
              totalVulnerableDamage += psvulnerDamage;
            }
            
            // アリア＆ティナのPS脆弱（専5以上で1ラウンドに1度）
            if (hero.name === 'アリア＆ティナ' && data.psVulnerable) {
              const psInfo = data.psVulnerable(exLv);
              if (psInfo) {
                const vulnerBoost = 100 + globalVulnerableBoost;
                // 脆弱ダメージ = (直接攻撃火力 / 直接攻撃弾数) × (脆弱値 / 100%) × 付与数 × 発動率 × 脆弱強化
                const ariaPSVulnerDamage = psInfo.rate * (totalDirectDamage / (totalDirectBullets || 1)) *
                                           (psInfo.value / 100) * psInfo.count * (vulnerBoost / 100);
                totalASDamage += ariaPSVulnerDamage;
                totalVulnerableDamage += ariaPSVulnerDamage;
                // 脆弱数期待値を集計
                totalVulnerableBulletsExpected += psInfo.rate * psInfo.count;
              }
            }
          });

          // 全軍突撃の計算（R1重み適用）
          let rushBonus = 0;
          if (useTitan) {
            heroes.forEach((hero, i) => {
              const data = heroData[hero.name];
              if (!data || data.name === '未実装' || data.name === '外す') return;

              // 全軍突撃装備の検出
              let hasRush = false;
              let rushValue = 0;
              titanEquip[i].forEach((equip, slotIdx) => {
                if (equip.effect === '全軍突撃' && slotNames[slotIdx] === 'rifle') {
                  const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '全軍突撃');
                  if (effect && effect.levels) {
                    hasRush = true;
                    rushValue = effect.levels[equip.level - 1];
                  }
                }
              });

              if (hasRush && data.asRate) {
                const baseRate = typeof data.asRate === 'function' ? data.asRate(exLv) : data.asRate;
                const actualRate = baseRate * (9 - buffs.silenceCount) / 9 / 100;
                const exLv = hero.exclusiveLv;
                
                // AS直接ダメージの全突分
                if (data.asDamage && data.asBullets) {
                  const bullets = typeof data.asBullets === 'function' ? data.asBullets(exLv) : data.asBullets;
                  const damage = data.asDamage(exLv);
                  rushBonus += actualRate * damage * bullets * (rushValue / 100);
                }

                // ペトラのAS追加磁気の全突分（磁気属性だが全突対象）
                if (hero.name === 'ペトラ' && data.asExtraEffect) {
                  const extra = data.asExtraEffect(exLv, hasCombo);
                  if (extra) {
                    const bulletCoefficient = 1.5 + runeMagneticBonus;
                    const adjustedBullets = (exLv >= 5 ? 5 : 4) * 0.5 * bulletCoefficient;
                    const magneticBoost = 100 + globalMagneticBoost + localMagneticBoosts[i];
                    rushBonus += actualRate * extra.damage * adjustedBullets * magneticBoost / 100 * (rushValue / 100);
                  }
                }

                // アカネのAS拡散ダメの全突分
                if (hero.name === 'アカネ' && data.asScatterDamage) {
                  const scatterInfo = data.asScatterDamage(exLv, totalMagneticBulletsExpected, magneticHeroCount);
                  rushBonus += actualRate * scatterInfo.damage * scatterInfo.bullets * (rushValue / 100);
                }

                // 磁場（磁気付与）の全突分
                titanEquip[i].forEach((equip, slotIdx) => {
                  if (equip.effect === '磁場' && ['rifle', 'vision', 'handy'].includes(slotNames[slotIdx])) {
                    const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '磁場');
                    if (effect && effect.levels && effect.counts) {
                      const magneticValue = effect.levels[equip.level - 1];
                      const magneticCount = effect.counts[equip.level - 1];
                      const magneticBoost = 100 + globalMagneticBoost + localMagneticBoosts[i];
                      rushBonus += actualRate * magneticValue * magneticCount * magneticBoost / 100 * (rushValue / 100);
                    }
                  }

                  // 灼熱（燃焼付与）の全突分
                  if (equip.effect === '灼熱' && ['rifle', 'vision', 'handy'].includes(slotNames[slotIdx])) {
                    const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '灼熱');
                    if (effect && effect.levels && effect.counts) {
                      const burningValue = effect.levels[equip.level - 1];
                      const burningCount = effect.counts[equip.level - 1];
                      const burningBoost = 100 + globalBurningBoost + localBurningBoosts[i];
                      rushBonus += actualRate * burningValue * burningCount * burningBoost / 100 * (rushValue / 100);
                    }
                  }

                  // 破凱（脆弱付与）の全突分
                  if (equip.effect === '破凱' && ['rifle', 'vision', 'handy'].includes(slotNames[slotIdx])) {
                    const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '破凱');
                    if (effect && effect.levels && effect.counts && effect.lossCoefs) {
                      const vulnerValue = effect.levels[equip.level - 1];
                      const vulnerCount = effect.counts[equip.level - 1];
                      const lossCoef = effect.lossCoefs[equip.level - 1];
                      const vulnerBoost = 100 + localVulnerBoosts[i] + globalVulnerableBoost;
                      const vulnerDamage = actualRate * (totalDirectDamage / (totalDirectBullets || 1)) * 
                                          (vulnerValue / 100) * (vulnerCount * (lossCoef * 0.95)) * 
                                          (vulnerBoost / 100);
                      rushBonus += vulnerDamage * (rushValue / 100);
                    }
                  }
                });
              }
            });
            
            // R1重み（火力用）を適用
            const rushContribution = rushBonus * powerRoundWeights[0];
            totalASDamage += rushContribution;
          }

          let heroBasePower = (100 + totalAttackBuff) / 100;
          let heroBaseDurability = (100 + totalShieldBuff) / 100;

          // ダメ増・ダメ減補正係数の計算
          // 補正係数 = (タイタン等による加算 + 元のバフ+100%) / (元のバフ+100%)
          let damageIncreaseCoeff = 1.0;
          let damageReductionCoeff = 1.0;
          
          // ソフィ編成ボーナス（ダメ増減各+20%）※ヒヨリ単独では発動しない
          let sofiDamageBoost = 0;
          const hasHiyori = heroes.some(h => h.name === 'ヒヨリ');
          const hasSofi = heroes.some(h => h.name === 'ソフィ');
          if (hasSofi) {
            sofiDamageBoost = 20;
          }
          
          // 戦場洞察（タイタンON時）+ ソフィボーナス → ダメ増・ダメ減補正係数
          const totalDamageIncreaseBonus = (useTitan ? totalInsightValue : 0) + sofiDamageBoost;
          const totalDamageReductionBonus = (useTitan ? totalElusivenessValue : 0) + sofiDamageBoost;
          
          if (totalDamageIncreaseBonus > 0) {
            damageIncreaseCoeff = (totalDamageIncreaseBonus + (buffs.damageIncrease + 100)) / (buffs.damageIncrease + 100);
            heroBasePower *= damageIncreaseCoeff;
          }
          if (totalDamageReductionBonus > 0) {
            damageReductionCoeff = (totalDamageReductionBonus + (buffs.damageReduction + 100)) / (buffs.damageReduction + 100);
            heroBaseDurability *= damageReductionCoeff;
          }

          // 鉄壁耐久補正の計算（破壊不能対応、各英雄で計算して最大値を採用）
          // タイタンOFFでも英雄の基礎値は適用される
          let ironWallCorrection = 1.0;
          
          if (hasIronWall) {
            let maxCorrection = 1.0;
            
            heroes.forEach((hero, i) => {
              const data = heroData[hero.name];
              if (!data || data.name === '未実装' || data.name === '外す' || !data.ironWallValue) return;
              
              const exLv = hero.exclusiveLv;
              const ironValue = data.ironWallValue(exLv);
              const ironRounds = data.ironWallRounds ? data.ironWallRounds(exLv) : 1;
              
              // 基礎鉄壁耐久係数（タイタンOFFでも適用）
              let baseCorrection = 1.0;
              if (exLv < 5) {
                baseCorrection = 1.21;
              } else if (exLv === 5) {
                baseCorrection = 1.516;
              } else {
                baseCorrection = 1.8;
              }
              
              // 破壊不能による補正（タイタンONのみ）
              let destructibleBonus = 0;
              if (useTitan) {
                titanEquip[i].forEach((equip, slotIdx) => {
                  if (equip.effect === '破壊不能' && slotNames[slotIdx] === 'armor') {
                    const effect = titanEffects[slotNames[slotIdx]].effects.find(e => e.name === '破壊不能');
                    if (effect && effect.levels) {
                      const destructibleValue = effect.levels[equip.level - 1];
                      
                      // 破壊不能重み = (鉄壁ラウンド数+1)のラウンド重み
                      // R1,R2,R3,R4以降 → index 0,1,2,3
                      const roundIndex = Math.min(ironRounds, durabilityRoundWeights.length - 1);
                      const destructibleWeight = durabilityRoundWeights[roundIndex];
                      
                      // 専用倍率込みの鉄壁値（％）
                      const adjustedIronValue = ironValue * exclusiveMultipliers[exLv];
                      
                      // 補正計算: ((破壊不能重み/(1-(鉄壁値% × 破壊不能値%))) - 破壊不能重み)
                      const denominator = 1 - (adjustedIronValue / 100) * (destructibleValue / 100);
                      if (denominator > 0) {
                        destructibleBonus = (destructibleWeight / denominator) - destructibleWeight;
                      }
                    }
                  }
                });
              }
              
              let finalCorrection = baseCorrection + destructibleBonus;
              
              // 上限チェック
              if (exLv >= 7) {
                finalCorrection = Math.min(finalCorrection, 3.33);
              } else if (exLv >= 5) {
                finalCorrection = Math.min(finalCorrection, 2.0);
              }
              
              maxCorrection = Math.max(maxCorrection, finalCorrection);
            });
            
            ironWallCorrection = maxCorrection;
          }

          const passiveDamage = totalPSDamage;
          const heroPower = heroBasePower * (passiveDamage + totalASDamage) / 100;
          const heroDurability = heroBaseDurability * ironWallCorrection * totalDebuffDurabilityCorrection;
          const heroStrength = heroPower * heroDurability;

          // ダメージ属性の構造（将来的な拡張用）
          // damageBreakdown = {
          //   direct: { // 直接ダメージ（脆弱の影響を受ける）
          //     as: AS直接ダメージの合計,
          //     normal: 通常攻撃ダメージ
          //   },
          //   magnetic: 磁気ダメージの合計,
          //   burning: 燃焼ダメージの合計,
          //   weaken: 衰弱値（耐久に寄与）,
          //   vulnerable: 脆弱値（直接ダメージ強化）
          // }

          // （追撃火力／総火力）／弾数
          const rushRatio = totalASBullets > 0 ? 
            (totalASDamage / (totalASDamage + passiveDamage)) / totalASBullets : 
            0;
          
          // 直接ダメージ総計／弾数 = (全直接ダメージ + 脆弱ダメージ) / 直接ダメージ弾数期待値
          const directDamagePerBullet = totalDirectBullets > 0 ?
            (totalDirectDamage + totalVulnerableDamage) / totalDirectBullets :
            0;

          return {
            heroBasePower,
            heroBaseDurability,
            damageIncreaseCoeff,
            damageReductionCoeff,
            totalASDamage,
            passiveDamage,
            ironWallCorrection,
            debuffDurabilityCorrection,
            armorDurabilityCorrection,
            totalDebuffDurabilityCorrection,
            rushRatio,
            directDamagePerBullet,
            heroPower,
            heroDurability,
            heroStrength
          };
        };

        const withTitan = calculateHeroStats(titanEnabled);
        const withoutTitan = calculateHeroStats(false);

        const calcIncrease = (withVal, withoutVal) => {
          if (withoutVal === 0) return 0;
          return ((withVal - withoutVal) / withoutVal * 100).toFixed(1);
        };

        // 予想戦闘ターンの計算
        const calculateExpectedRounds = (myRatio, enemyRatio, powerDiff) => {
          // α = √(自火力耐久比) / √(想定戦力差 / 敵火力耐久比)
          const alpha = Math.sqrt(myRatio) / Math.sqrt(powerDiff / enemyRatio);
          
          // β = √(想定戦力差 × 敵火力耐久比) / √(1 / 自火力耐久比)
          const beta = Math.sqrt(powerDiff * enemyRatio) / Math.sqrt(1 / myRatio);
          
          // hpRratio = √(敵火力耐久比 / (想定戦力差 × 自火力耐久比))
          const hpRratio = Math.sqrt(enemyRatio / (powerDiff * myRatio));
          
          // 最大値 = 2 / √(α × β)
          const maxRoundLength = 2 / Math.sqrt(alpha * beta);
          
          let roundLength;
          
          // ①想定戦力差がそのままの方が小さい場合 (powerDiff < 1/powerDiff)
          // つまり powerDiff < 1
          if (powerDiff < 1 / powerDiff) {
            // roundLength = 1/√(α×β) × arctanh(√(β/α) × 1/hpRatio)
            const arg = Math.sqrt(beta / alpha) * (1 / hpRratio);
            
            // atanhの引数は-1から1の範囲でなければならない
            if (Math.abs(arg) >= 1) {
              // 発散する場合は最大値を使用
              roundLength = maxRoundLength;
            } else {
              roundLength = (1 / Math.sqrt(alpha * beta)) * Math.atanh(arg);
              
              // 発散対策：最大値を超えた場合
              if (!isFinite(roundLength) || roundLength > maxRoundLength) {
                roundLength = maxRoundLength;
              }
            }
          } else {
            // ②逆数の方が小さい場合 (1/powerDiff < powerDiff)
            // つまり powerDiff > 1
            // roundLength = 1/√(α×β) × arctanh(√(α/β) × hpRatio)
            const arg = Math.sqrt(alpha / beta) * hpRratio;
            
            // atanhの引数は-1から1の範囲でなければならない
            if (Math.abs(arg) >= 1) {
              // 発散する場合は最大値を使用
              roundLength = maxRoundLength;
            } else {
              roundLength = (1 / Math.sqrt(alpha * beta)) * Math.atanh(arg);
              
              // 発散対策：最大値を超えた場合
              if (!isFinite(roundLength) || roundLength > maxRoundLength) {
                roundLength = maxRoundLength;
              }
            }
          }
          
          return roundLength;
        };
        
        const expectedRounds = calculateExpectedRounds(buffs.myPowerDurabilityRatio, buffs.enemyPowerDurabilityRatio, buffs.powerDiff);

        return {
          typeWarning,
          compatDurability,
          compatPower,
          compatStrength,
          compatTroopDurability,
          compatTroopPower,
          compatTroopStrength,
          compatTroopSoldierDurability,
          compatTroopSoldierPower,
          compatTroopSoldierStrength,
          expectedRounds,
          ...withTitan,
          // 編成総合評価
          totalPower: withTitan.heroPower * compatTroopSoldierPower,
          totalDurability: withTitan.heroDurability * compatTroopSoldierDurability,
          // 総合強さ値は1B^2がかからないように計算
          totalStrength: (withTitan.heroPower * compatTroopSoldierPower / 1000000000) * (withTitan.heroDurability * compatTroopSoldierDurability / 1000000000),
          increases: {
            heroBasePower: calcIncrease(withTitan.heroBasePower, withoutTitan.heroBasePower),
            heroBaseDurability: calcIncrease(withTitan.heroBaseDurability, withoutTitan.heroBaseDurability),
            damageIncreaseCoeff: calcIncrease(withTitan.damageIncreaseCoeff, withoutTitan.damageIncreaseCoeff),
            damageReductionCoeff: calcIncrease(withTitan.damageReductionCoeff, withoutTitan.damageReductionCoeff),
            totalASDamage: calcIncrease(withTitan.totalASDamage, withoutTitan.totalASDamage),
            passiveDamage: calcIncrease(withTitan.passiveDamage, withoutTitan.passiveDamage),
            ironWallCorrection: calcIncrease(withTitan.ironWallCorrection, withoutTitan.ironWallCorrection),
            debuffDurabilityCorrection: calcIncrease(withTitan.debuffDurabilityCorrection, withoutTitan.debuffDurabilityCorrection),
            armorDurabilityCorrection: calcIncrease(withTitan.armorDurabilityCorrection, withoutTitan.armorDurabilityCorrection),
            totalDebuffDurabilityCorrection: calcIncrease(withTitan.totalDebuffDurabilityCorrection, withoutTitan.totalDebuffDurabilityCorrection),
            heroPower: calcIncrease(withTitan.heroPower, withoutTitan.heroPower),
            heroDurability: calcIncrease(withTitan.heroDurability, withoutTitan.heroDurability),
            heroStrength: calcIncrease(withTitan.heroStrength, withoutTitan.heroStrength),
            totalPower: calcIncrease(withTitan.heroPower * compatTroopSoldierPower, withoutTitan.heroPower * compatTroopSoldierPower),
            totalDurability: calcIncrease(withTitan.heroDurability * compatTroopSoldierDurability, withoutTitan.heroDurability * compatTroopSoldierDurability),
            totalStrength: calcIncrease(
              (withTitan.heroPower * compatTroopSoldierPower / 1000000000) * (withTitan.heroDurability * compatTroopSoldierDurability / 1000000000),
              (withoutTitan.heroPower * compatTroopSoldierPower / 1000000000) * (withoutTitan.heroDurability * compatTroopSoldierDurability / 1000000000)
            )
          }
        };
      }, [buffs, compatibility, heroes, titanEquip, titanEnabled, powerRoundWeights, durabilityRoundWeights]);

      return (
        <div className="container">
          {/* ヘッダー */}
          <div className="header">
            <h1>
              <CalculatorIcon />
              英雄タイタン強さ評価ツール
              <span className="version-badge">v2.0 Phase 3</span>
            </h1>
            <p>by Napo  feat.Sonnet</p>
          </div>

          <div className="grid">
            {/* 左カラム：バフ設定 */}
            <div className="space-y-6">
              <div className="card">
                <div className="card-header" onClick={() => toggleTab('buffs')}>
                  <h2><ShieldIcon /> バフ設定</h2>
                  <span className={`collapse-icon ${!expandedTabs.buffs ? 'collapsed' : ''}`}>▼</span>
                </div>
                <div className={`card-content ${!expandedTabs.buffs ? 'hidden' : ''}`}>
                  <div className="space-y-3">
                  <div className="form-group">
                    <label className="form-label">出撃数</label>
                    <input
                      type="number"
                      value={buffs.troops}
                      onChange={(e) => updateBuff('troops', e.target.value)}
                      className="form-input"
                    />
                  </div>

                  <div className="form-group">
                    <label className="form-label">兵士Lv</label>
                    <select
                      value={buffs.soldierLv}
                      onChange={(e) => updateBuff('soldierLv', e.target.value)}
                      className="form-select"
                    >
                      {[103, 102, 101, 100, 83, 82, 81, 80].map(lv => (
                        <option key={lv} value={lv}>Lv {lv}</option>
                      ))}
                    </select>
                  </div>

                  {[
                    { key: 'life', label: '生命' },
                    { key: 'attack', label: '攻撃' },
                    { key: 'damageIncrease', label: 'ダメ増' },
                    { key: 'damageReduction', label: 'ダメ減' },
                    { key: 'defense', label: '防御' }
                  ].map(({ key, label }) => (
                    <div key={key} className="form-group">
                      <label className="form-label">{label} (%)</label>
                      <input
                        type="number"
                        value={buffs[key]}
                        onChange={(e) => updateBuff(key, e.target.value)}
                        className="form-input"
                      />
                    </div>
                  ))}

                  <div className="form-group">
                    <label className="form-label">基礎開戦シールド</label>
                    <select
                      value={buffs.baseShield}
                      onChange={(e) => updateBuff('baseShield', e.target.value)}
                      className="form-select"
                    >
                      {[0, 5, 18, 23, 28, 33, 40, 45].map(val => (
                        <option key={val} value={val}>{val}</option>
                      ))}
                    </select>
                  </div>
                </div>
                </div>
              </div>

              <div className="card">
                <div className="card-header" onClick={() => toggleTab('environment')}>
                  <h2><SwordsIcon /> 相性環境設定</h2>
                  <span className={`collapse-icon ${!expandedTabs.environment ? 'collapsed' : ''}`}>▼</span>
                </div>
                <div className={`card-content ${!expandedTabs.environment ? 'hidden' : ''}`}>
                  <div className="space-y-3">
                  <div className="form-group">
                    <label className="form-label">兵種相性設定 (%)</label>
                    <input
                      type="number"
                      value={buffs.typeAdvantage}
                      onChange={(e) => updateBuff('typeAdvantage', e.target.value)}
                      className="form-input"
                    />
                  </div>

                  <div className="form-group">
                    <label className="form-label">有利・同兵種・不利</label>
                    <div className="compatibility-buttons">
                      {['同兵種', '有利', '不利'].map(comp => (
                        <button
                          key={comp}
                          onClick={() => setCompatibility(comp)}
                          className={`btn ${compatibility === comp ? 'btn-primary active' : 'btn-secondary'}`}
                        >
                          {comp}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="form-group">
                    <label className="form-label">敵から受ける沈黙の数</label>
                    <input
                      type="number"
                      value={buffs.silenceCount}
                      onChange={(e) => updateBuff('silenceCount', e.target.value)}
                      className="form-input"
                    />
                  </div>

                  <div className="form-group">
                    <label className="form-label">敵の鉄壁条件</label>
                    <select
                      value={buffs.enemyIronWall}
                      onChange={(e) => updateBuff('enemyIronWall', e.target.value)}
                      className="form-select"
                    >
                      <option value="鉄壁無し">鉄壁無し</option>
                      <option value="専用なし">専用なし</option>
                      <option value="専用5">専用5</option>
                      <option value="専用7">専用7</option>
                      <option value="専用7＋Lv7破壊不能">専用7＋Lv7破壊不能</option>
                    </select>
                  </div>

                  <div className="form-group">
                    <label className="form-label">想定戦力差（強さ値が自身の何倍）</label>
                    <input
                      type="number"
                      step="0.1"
                      min="0"
                      value={buffs.powerDiff}
                      onChange={(e) => updateBuff('powerDiff', e.target.value)}
                      className="form-input"
                    />
                  </div>

                  <div className="form-group">
                    <label className="form-label">敵の火力／耐久比（0.1～0.5）</label>
                    <input
                      type="number"
                      step="0.01"
                      min="0.1"
                      max="0.5"
                      value={buffs.enemyPowerDurabilityRatio}
                      onChange={(e) => updateBuff('enemyPowerDurabilityRatio', e.target.value)}
                      className="form-input"
                    />
                  </div>

                  <div className="form-group">
                    <label className="form-label">自編成の火力／耐久比（0.1～0.5）</label>
                    <input
                      type="number"
                      step="0.01"
                      min="0.1"
                      max="0.5"
                      value={buffs.myPowerDurabilityRatio}
                      onChange={(e) => updateBuff('myPowerDurabilityRatio', e.target.value)}
                      className="form-input"
                    />
                  </div>

                  {/* 予想戦闘ターン表示 */}
                  <div className="result-box" style={{ background: 'rgba(59, 130, 246, 0.2)', marginTop: '0.5rem' }}>
                    <div className="result-label">予想戦闘ターン</div>
                    <div className="result-value value-blue">{formatNumber(calculations.expectedRounds)}</div>
                  </div>

                  {/* ラウンド重み係数 */}
                  <div style={{ marginTop: '1rem', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '1rem' }}>
                    <div style={{ marginBottom: '0.5rem', fontWeight: 'bold', color: '#fbbf24' }}>火力ラウンド重み係数</div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '0.5rem' }}>
                      {['R1', 'R2', 'R3', 'R4以降'].map((label, idx) => (
                        <div key={idx} className="form-group" style={{ marginBottom: 0 }}>
                          <label className="form-label" style={{ fontSize: '0.75rem' }}>{label}</label>
                          <input
                            type="number"
                            step="0.01"
                            value={powerRoundWeights[idx]}
                            onChange={(e) => {
                              const newWeights = [...powerRoundWeights];
                              newWeights[idx] = parseFloat(e.target.value) || 0;
                              setPowerRoundWeights(newWeights);
                            }}
                            className="form-input"
                            style={{ fontSize: '0.875rem' }}
                          />
                        </div>
                      ))}
                    </div>
                  </div>

                  <div style={{ marginTop: '1rem', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '1rem' }}>
                    <div style={{ marginBottom: '0.5rem', fontWeight: 'bold', color: '#86efac' }}>耐久ラウンド重み係数</div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '0.5rem' }}>
                      {['R1', 'R2', 'R3', 'R4以降'].map((label, idx) => (
                        <div key={idx} className="form-group" style={{ marginBottom: 0 }}>
                          <label className="form-label" style={{ fontSize: '0.75rem' }}>{label}</label>
                          <input
                            type="number"
                            step="0.01"
                            value={durabilityRoundWeights[idx]}
                            onChange={(e) => {
                              const newWeights = [...durabilityRoundWeights];
                              newWeights[idx] = parseFloat(e.target.value) || 0;
                              setDurabilityRoundWeights(newWeights);
                            }}
                            className="form-input"
                            style={{ fontSize: '0.875rem' }}
                          />
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* 敵の追撃火力比率 */}
                  <div className="form-group" style={{ marginTop: '1rem' }}>
                    <label className="form-label">敵の（追撃火力／総火力）／弾数（重甲の計算用）</label>
                    <input
                      type="number"
                      step="0.01"
                      value={buffs.enemyRushRatio}
                      onChange={(e) => updateBuff('enemyRushRatio', e.target.value)}
                      className="form-input"
                    />
                  </div>
                </div>
                </div>
              </div>
            </div>

            {/* 中央カラム：英雄設定 */}
            <div className="space-y-6">
              <div className="card">
                <div className="card-header" onClick={() => toggleTab('heroes')}>
                  <h2><UsersIcon /> 英雄設定</h2>
                  <span className={`collapse-icon ${!expandedTabs.heroes ? 'collapsed' : ''}`}>▼</span>
                </div>
                {/* 兵種不一致の警告：常時表示（タブ折りたたみに関わらず） */}
                {calculations.typeWarning && (
                  <div style={{
                    background: 'rgba(220, 38, 38, 0.2)',
                    border: '1px solid rgba(239, 68, 68, 0.5)',
                    borderRadius: '0.375rem',
                    padding: '0.5rem 0.75rem',
                    marginBottom: '0.5rem',
                    color: '#fca5a5',
                    fontWeight: '600',
                    fontSize: '0.875rem'
                  }}>
                    {calculations.typeWarning}
                  </div>
                )}
                <div className={`card-content ${!expandedTabs.heroes ? 'hidden' : ''}`}>
                
                {/* プリセット選択（コンパクト） */}
                <div style={{ marginBottom: '1rem' }}>
                  <label className="form-label" style={{ marginBottom: '0.5rem' }}>プリセット選択</label>
                  <div className="preset-grid">
                    {Object.entries(presets).map(([num, names]) => (
                      <button
                        key={num}
                        onClick={() => selectPreset(parseInt(num))}
                        className="preset-btn"
                        style={{ padding: '0.5rem', fontSize: '0.875rem' }}
                      >
                        <span className="preset-label">P{num}</span>
                        <span className="preset-heroes" style={{ fontSize: '0.75rem' }}>{names.join('・')}</span>
                      </button>
                    ))}
                  </div>
                </div>

                {/* 英雄個別設定 */}
                <div className="space-y-4">
                  {heroes.map((hero, i) => (
                    <div key={i} className="hero-card">
                      <div className="hero-title">
                        英雄 {i + 1}
                        {heroData[hero.name]?.type && (
                          <span className={`hero-type-badge type-${
                            heroData[hero.name].type === '陸軍' ? 'land' :
                            heroData[hero.name].type === '海軍' ? 'sea' : 'air'
                          }`}>
                            {heroData[hero.name].type}
                          </span>
                        )}
                      </div>
                      <div className="hero-grid">
                        <div className="form-group">
                          <label className="form-label">名前</label>
                          <select
                            value={hero.name}
                            onChange={(e) => updateHero(i, 'name', e.target.value)}
                            className="form-select"
                          >
                            {Object.keys(heroData).map(name => (
                              <option key={name} value={name}>{name}</option>
                            ))}
                          </select>
                        </div>
                        <div className="form-group">
                          <label className="form-label">専用Lv</label>
                          <select
                            value={hero.exclusiveLv}
                            onChange={(e) => updateHero(i, 'exclusiveLv', parseInt(e.target.value))}
                            className="form-select"
                          >
                            <option value={0}>専用なし</option>
                            <option value={3}>専用3</option>
                            <option value={5}>専用5</option>
                            <option value={7}>専用7</option>
                          </select>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
                </div>
              </div>

              <div className="card">
                <div className="card-header" onClick={() => toggleTab('titanEquip')}>
                  <h2><SettingsIcon /> タイタン装備</h2>
                  <span className={`collapse-icon ${!expandedTabs.titanEquip ? 'collapsed' : ''}`}>▼</span>
                </div>
                <div className={`card-content ${!expandedTabs.titanEquip ? 'hidden' : ''}`}>
                
                <div className="toggle-container">
                  <div 
                    className={`toggle-switch ${titanEnabled ? 'active' : ''}`}
                    onClick={() => setTitanEnabled(!titanEnabled)}
                  >
                    <div className="toggle-slider"></div>
                  </div>
                  <span className="toggle-label">
                    タイタン効果: {titanEnabled ? 'ON' : 'OFF'}
                  </span>
                </div>

                <div className="space-y-6">
                  {heroes.map((hero, heroIdx) => (
                    <div key={heroIdx} className="titan-section">
                      <div 
                        className="card-header" 
                        onClick={() => toggleTitanHero(heroIdx)}
                        style={{ cursor: 'pointer', marginBottom: '0.5rem' }}
                      >
                        <div className="titan-hero-name" style={{ margin: 0 }}>{hero.name}</div>
                        <span className={`collapse-icon ${!expandedTitanHeroes[heroIdx] ? 'collapsed' : ''}`}>▼</span>
                      </div>
                      {expandedTitanHeroes[heroIdx] && (
                        <div className="space-y-3">
                          {slotNames.map((slotName, slotIdx) => {
                            const Icon = slotIcons[slotName];
                            return (
                              <div key={slotIdx} className="titan-slot">
                                <div className="titan-slot-header">
                                  <Icon />
                                  <span>{slotDisplayNames[slotIdx]}</span>
                                </div>
                                <div className="titan-slot-grid">
                                  <select
                                    value={titanEquip[heroIdx][slotIdx].effect}
                                    onChange={(e) => updateTitan(heroIdx, slotIdx, 'effect', e.target.value)}
                                    className="form-select"
                                    style={{ fontSize: '0.875rem' }}
                                  >
                                    <option value="">選択なし</option>
                                    {titanEffects[slotName].effects.map((eff, i) => (
                                      <option key={i} value={eff.name}>
                                        {eff.name} ({eff.desc})
                                      </option>
                                    ))}
                                  </select>
                                  {titanEquip[heroIdx][slotIdx].effect && (
                                    <select
                                      value={titanEquip[heroIdx][slotIdx].level}
                                      onChange={(e) => updateTitan(heroIdx, slotIdx, 'level', parseInt(e.target.value))}
                                      className="form-select"
                                      style={{ fontSize: '0.875rem' }}
                                    >
                                      {(() => {
                                        const effect = titanEffects[slotName].effects.find(
                                          e => e.name === titanEquip[heroIdx][slotIdx].effect
                                        );
                                        const maxLv = effect ? effect.levels.length : 7;
                                        return Array.from({ length: maxLv }, (_, i) => (
                                          <option key={i} value={i + 1}>Lv {i + 1}</option>
                                        ));
                                      })()}
                                    </select>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
                </div>
              </div>
            </div>

            {/* 右カラム：計算結果 */}
            <div className="space-y-6">
              <div className="card">
                <div className="card-header" onClick={() => toggleTab('buffCalc')}>
                  <h2 style={{ color: '#86efac' }}>バフ相性計算</h2>
                  <span className={`collapse-icon ${!expandedTabs.buffCalc ? 'collapsed' : ''}`}>▼</span>
                </div>
                <div className={`card-content ${!expandedTabs.buffCalc ? 'hidden' : ''}`}>
                  <div className="space-y-2">
                  {/* 耐久と火力を2列並び */}
                  <div className="result-grid-2">
                    <div className="result-box">
                      <div className="result-label">バフ相性耐久</div>
                      <div className="result-value value-green">{formatNumber(calculations.compatDurability)}</div>
                    </div>
                    <div className="result-box">
                      <div className="result-label">バフ相性火力</div>
                      <div className="result-value value-red">{formatNumber(calculations.compatPower)}</div>
                    </div>
                  </div>
                  
                  {/* 強さ値（強調） */}
                  <div className="result-box" style={{ background: 'linear-gradient(to right, rgba(202, 138, 4, 0.2), rgba(234, 179, 8, 0.2))' }}>
                    <div className="result-label">バフ相性強さ値</div>
                    <div className="result-value value-yellow" style={{ fontSize: '1.25rem' }}>{formatNumber(calculations.compatStrength)}</div>
                  </div>
                  
                  {/* 出撃耐久と火力を2列並び */}
                  <div className="result-grid-2">
                    <div className="result-box">
                      <div className="result-label">バフ相性出撃耐久</div>
                      <div className="result-value value-green">{formatNumber(calculations.compatTroopDurability)}</div>
                    </div>
                    <div className="result-box">
                      <div className="result-label">バフ相性出撃火力</div>
                      <div className="result-value value-red">{formatNumber(calculations.compatTroopPower)}</div>
                    </div>
                  </div>
                  
                  {/* 出撃強さ値（強調） */}
                  <div className="result-box" style={{ background: 'linear-gradient(to right, rgba(202, 138, 4, 0.2), rgba(234, 179, 8, 0.2))' }}>
                    <div className="result-label">バフ相性出撃強さ値</div>
                    <div className="result-value value-yellow" style={{ fontSize: '1.25rem' }}>{formatNumber(calculations.compatTroopStrength)}</div>
                  </div>
                  
                  {/* 兵士耐久と火力を2列並び */}
                  <div className="result-grid-2">
                    <div className="result-box">
                      <div className="result-label">バフ相性出撃兵士耐久</div>
                      <div className="result-value value-green">{formatNumber(calculations.compatTroopSoldierDurability)}</div>
                    </div>
                    <div className="result-box">
                      <div className="result-label">バフ相性出撃兵士火力</div>
                      <div className="result-value value-red">{formatNumber(calculations.compatTroopSoldierPower)}</div>
                    </div>
                  </div>
                  
                  {/* 兵士強さ値（強調） */}
                  <div className="result-box" style={{ background: 'linear-gradient(to right, rgba(202, 138, 4, 0.2), rgba(234, 179, 8, 0.2))' }}>
                    <div className="result-label">バフ相性出撃兵士強さ値</div>
                    <div className="result-value value-yellow" style={{ fontSize: '1.25rem' }}>{formatNumber(calculations.compatTroopSoldierStrength)}</div>
                  </div>
                </div>
                </div>
              </div>

              <div className="card">
                <div className="card-header" onClick={() => toggleTab('heroCalc')}>
                  <h2 style={{ color: '#c084fc' }}>英雄計算</h2>
                  <span className={`collapse-icon ${!expandedTabs.heroCalc ? 'collapsed' : ''}`}>▼</span>
                </div>
                <div className={`card-content ${!expandedTabs.heroCalc ? 'hidden' : ''}`}>
                  <div className="space-y-2">
                  {/* 火力と耐久の項目を2列並び */}
                  <div className="result-grid-2">
                    <div className="result-box">
                      <div className="result-label">
                        <span>基礎英雄火力</span>
                        {titanEnabled && calculations.increases.heroBasePower > 0 && (
                          <span className="result-increase">+{calculations.increases.heroBasePower}%</span>
                        )}
                      </div>
                      <div className="result-value value-red">{formatNumber(calculations.heroBasePower)}倍</div>
                    </div>
                    <div className="result-box">
                      <div className="result-label">
                        <span>基礎英雄耐久</span>
                        {titanEnabled && calculations.increases.heroBaseDurability > 0 && (
                          <span className="result-increase">+{calculations.increases.heroBaseDurability}%</span>
                        )}
                      </div>
                      <div className="result-value value-green">{formatNumber(calculations.heroBaseDurability)}倍</div>
                    </div>
                  </div>

                  <div className="result-grid-2">
                    <div className="result-box">
                      <div className="result-label">
                        <span>AS総ダメージ</span>
                        {titanEnabled && calculations.increases.totalASDamage > 0 && (
                          <span className="result-increase">+{calculations.increases.totalASDamage}%</span>
                        )}
                      </div>
                      <div className="result-value value-yellow">{formatNumber(calculations.totalASDamage)}%</div>
                    </div>
                    <div className="result-box">
                      <div className="result-label">
                        <span>パッシブダメージ</span>
                        {titanEnabled && calculations.increases.passiveDamage > 0 && (
                          <span className="result-increase">+{calculations.increases.passiveDamage}%</span>
                        )}
                      </div>
                      <div className="result-value value-orange">{formatNumber(calculations.passiveDamage)}%</div>
                    </div>
                  </div>

                  <div className="result-grid-2">
                    <div className="result-box">
                      <div className="result-label">
                        <span>鉄壁耐久補正</span>
                        {titanEnabled && calculations.increases.ironWallCorrection > 0 && (
                          <span className="result-increase">+{calculations.increases.ironWallCorrection}%</span>
                        )}
                      </div>
                      <div className="result-value value-blue">{formatNumber(calculations.ironWallCorrection)}</div>
                    </div>
                    <div className="result-box">
                      <div className="result-label">
                        <span>衰弱等耐久補正</span>
                        {titanEnabled && calculations.increases.totalDebuffDurabilityCorrection > 0 && (
                          <span className="result-increase">+{calculations.increases.totalDebuffDurabilityCorrection}%</span>
                        )}
                      </div>
                      <div className="result-value value-blue" style={{ fontWeight: 'bold' }}>{formatNumber(calculations.totalDebuffDurabilityCorrection)}</div>
                    </div>
                  </div>

                  {/* 強調項目 */}
                  <div className="result-box result-highlight">
                    <div className="result-label">
                      <span>英雄火力</span>
                      {titanEnabled && calculations.increases.heroPower > 0 && (
                        <span className="result-increase">+{calculations.increases.heroPower}%</span>
                      )}
                    </div>
                    <div className="result-value value-red" style={{ fontSize: '1.5rem' }}>
                      {formatNumber(calculations.heroPower)}倍
                    </div>
                  </div>
                  <div className="result-box result-highlight-green">
                    <div className="result-label">
                      <span>英雄耐久</span>
                      {titanEnabled && calculations.increases.heroDurability > 0 && (
                        <span className="result-increase">+{calculations.increases.heroDurability}%</span>
                      )}
                    </div>
                    <div className="result-value value-green" style={{ fontSize: '1.5rem' }}>
                      {formatNumber(calculations.heroDurability)}倍
                    </div>
                  </div>
                  <div className="result-box" style={{ background: 'linear-gradient(to right, rgba(202, 138, 4, 0.3), rgba(234, 179, 8, 0.3))' }}>
                    <div className="result-label">
                      <span>英雄強さ値</span>
                      {titanEnabled && calculations.increases.heroStrength > 0 && (
                        <span className="result-increase">+{calculations.increases.heroStrength}%</span>
                      )}
                    </div>
                    <div className="result-value value-yellow" style={{ fontSize: '1.5rem' }}>
                      {formatNumber(calculations.heroStrength)}
                    </div>
                  </div>

                  {/* 追撃火力比率 */}
                  <div className="result-box" style={{ marginTop: '0.5rem', opacity: '0.7' }}>
                    <div className="result-label">（追撃火力／総火力）／弾数</div>
                    <div className="result-value" style={{ fontSize: '0.875rem' }}>{formatNumber(calculations.rushRatio)}</div>
                  </div>
                  
                  {/* 直接ダメージ総計／弾数 */}
                  <div className="result-box" style={{ marginTop: '0.5rem', opacity: '0.7' }}>
                    <div className="result-label">直接ダメージ総計／弾数</div>
                    <div className="result-value" style={{ fontSize: '0.875rem' }}>{formatNumber(calculations.directDamagePerBullet)}%</div>
                  </div>
                </div>
                </div>
              </div>

              {/* 編成総合評価 */}
              <div className="card">
                <div className="card-header" onClick={() => toggleTab('totalEval')}>
                  <h2 style={{ color: '#fde047' }}>編成総合評価</h2>
                  <span className={`collapse-icon ${!expandedTabs.totalEval ? 'collapsed' : ''}`}>▼</span>
                </div>
                <div className={`card-content ${!expandedTabs.totalEval ? 'hidden' : ''}`}>
                  <div className="space-y-2">
                  {/* 総合耐久と総合火力を2列並び */}
                  <div className="result-grid-2">
                    <div className="result-box">
                      <div className="result-label">
                        <span>総合耐久</span>
                        {titanEnabled && calculations.increases.totalDurability > 0 && (
                          <span className="result-increase">+{calculations.increases.totalDurability}%</span>
                        )}
                      </div>
                      <div className="result-value value-green" style={{ fontSize: '1.25rem' }}>
                        {formatNumber(calculations.totalDurability)}
                      </div>
                    </div>
                    <div className="result-box">
                      <div className="result-label">
                        <span>総合火力</span>
                        {titanEnabled && calculations.increases.totalPower > 0 && (
                          <span className="result-increase">+{calculations.increases.totalPower}%</span>
                        )}
                      </div>
                      <div className="result-value value-red" style={{ fontSize: '1.25rem' }}>
                        {formatNumber(calculations.totalPower)}
                      </div>
                    </div>
                  </div>

                  {/* 編成総合強さ値（大きく強調） */}
                  <div className="result-box" style={{ background: 'linear-gradient(to right, rgba(202, 138, 4, 0.4), rgba(234, 179, 8, 0.4))', marginTop: '0.5rem' }}>
                    <div className="result-label">
                      <span>編成総合強さ値</span>
                      {titanEnabled && calculations.increases.totalStrength > 0 && (
                        <span className="result-increase">+{calculations.increases.totalStrength}%</span>
                      )}
                    </div>
                    <div className="result-value value-yellow" style={{ fontSize: '2rem', fontWeight: '900' }}>
                      {formatNumber(calculations.totalStrength)}
                    </div>
                  </div>
                </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<GameCalculator />, document.getElementById('root'));
  </script>
</body>
</html>